up:: [[Cybersecurity/Reverse Engineering & Malware Analysis/Software Reverse Engineering (SWRE)]]
down:: [[Cybersecurity/Reverse Engineering & Malware Analysis/Identifying Code Constructs in Reverse Engineering]]
down:: [[Cybersecurity/Reverse Engineering & Malware Analysis/x86 Assembly]]
# Reversing Object-Oriented C++

### The `this` Pointer

The `this` pointer, or pointer to the object, is heavily used in binaries.

- It appears in `ECX` as a "hidden" parameter.
- It is often used immediately before a member function call.
- If `ECX` is used without first being initialized, it could be related to the object, e.g., a member function.
- When an object is instantiated, the return value in `EAX` will be moved into `ECX` and used when calling the constructor.

All class methods use the `__thiscall` convention, which involves heavy usage of the `this` pointer. Frequently, the `this` pointer is passed to another register, such as `ESI` or `EDI`, or shuffled to a stack variable, effectively hiding in plain sight.

![[_assets/images/Disassembled-Cpp-Clues-Figure.png]]

### Virtual Methods 

- Virtual methods allow functions in the base class to be overridden in subclasses.
- They involve indirect calls that are given the `this` pointer.
- They can be followed via a vtable.

#### Virtual Function Tables

Virtual methods allow inherited functions to be overridden.

- Inherited functions can rewrite old base class function definitions.
- Even if not overridden, a vtable is necessary.
- Methods are placed in the order they are declared.

A vtable is located at the first 4 bytes of an object and consists of pointers to virtual functions. If there is multiple inheritance with virtual methods in subclasses, the subclass with the vtable is appended to the layout of the base class.

- Each subclass that has virtual methods will have a vtable.
- If an inherited class does not override or create new virtual methods, the original vtable can be used.

### Classes

Classes are used to create objects; they serve as the blueprint for an object.

- Check for the presence of a constructor and destructor.
- C++ is polymorphic, as it is Object-Oriented, so polymorphism is expected.
    - Are there virtual methods?
    - Is there run-time type information (RTTI)?
        - RTTI contains information on class details, including class name and class hierarchy.
        - It is located in the **`.rdata`** section, 4 bytes before the start of the object's virtual methods.
        - RTTI can be *absent* if binaries are stripped or non-polymorphic.

C++ and C have some critical differences that are important to be aware of during analysis.

Unlike C, C++ is an _object-oriented_ language.

- Descended from C, but enhanced with classes.
- C++ extends C structs in an object-oriented fashion.
- Objects can be instantiated and are comprised of both data members and functions.
- Functions within objects are known as methods.

C++ is a compiled, typed, self-managed language.

- There are many different ways to compile it: MS, GNU Project, LLVM/CLANG, Borland Intel.
- It supports smart pointers and raw pointers.

#### Object-Oriented Programming

Classes allow users to organize code with members and methods.

- Similar to structs, but enriched with methods.
- In a class, members are private by default, whereas in a struct they are public.

Classes define the layout of an object in terms of data and functions.

In C++, you must create an instance of an object of a specific class.

- There can be multiple instances of the same class, as well as instances of other classes.

Encapsulation means methods and data members are united as part of a class.

- This facilitates data hiding.
- Data members should be private and accessed only via methods.

**Example 1**
```cpp
#include <stdio.h>

class BaseClass {
public: 
    int x;
    void HelloFromBase() {
        puts("Base");
    }
};

class SubClass : public BaseClass {
public:
    int y;
    void HelloFromSub() {
        puts("Sub-Class");
    }
};

int main(int argc, char** argv, char** envp) {
    SubClass subInstance;
    subInstance.HelloFromBase();
    return 0;
}
```

**Example 2**
```cpp
#include <iostream>
using namespace std;

class Polygon {
protected:
    int width, height;
public:
    void set_values(int a, int b) {
        width = a;
        height = b;
    }
};

class Rectangle : public Polygon {
public:
    int area() {
        return width * height;
    }
};

class Triangle : public Polygon {
public:
    int area() {
        return width * height / 2;
    }
};

int main() {
    Rectangle rect;
    Triangle trg1;
    Polygon* ppoly1 = &rect;
    Polygon* ppoly2 = &trg1;
    ppoly1->set_values(4, 5);
    ppoly2->set_values(4, 5);
    cout << rect.area() << '\n';
    cout << trg1.area() << '\n';
    return 0;
}
```

Both C and C++ are procedural languages, meaning code constructs and syntax remain the same. However, C++ goes much further by introducing new features:

- **Object-Oriented**: Makes use of objects.
- **Polymorphism, Encapsulation, and Inheritance**: The special triad of object-oriented programming.
- **New Libraries**: For example, `cout` instead of `printf`.
- **New Types**: Vectors, lists, iterators.

#### Standard Template Library (STL)

The STL provides common classes for C++, such as containers, algorithms, methods, and iterators.

- **Common Programming Data Structures and Functions**: Includes lists, stacks, arrays, vectors.
- **Templates**: Heavily utilized to achieve polymorphism at compile-time.
- **Containers**: Objects that contain data (other objects) such as lists, vectors, stacks, etc.
- **Algorithms**: Used to manipulate data in containers, implementing iterators, etc.
- **Iterators**:
	- **Input**: Read values.
	- **Output**: Write values.
	- **Forward**: Read, write, and move forward.
	- **Bidirectional**: Move forward and backward.
	- **Random Access**: Direct access to any element.

##### Templates

Templates allow methods and classes to work with _generic types_.

- Classes, variables, and functions can be generalized.
- Many types can be used without rewriting functions repeatedly.
- Types are passed as **parameters** - either explicitly or implicitly.
    - Example: `max<int>(x, y);`.

```cpp
template <>
bool max<bool>(bool a, bool b) {
	return a || b;
}

template <typename Type>
Type max(Type a, Type b) {
	return a > b ? a : b;
}
```

Templates are simple, yet extremely effective. These get expanded at compiler-time using *appropriate* type.

```cpp
#include <iostream>
using namespace std;

// One function works for all data types. This would work
// even for user-defined types if operator '>' is overloaded.
template <typename T>
T myMax(T x, T y) {
    return (x > y) ? x : y;
}

int main() {
    cout << myMax<int>(3, 7) << endl;        // Call myMax for int
    cout << myMax<double>(3.0, 7.0) << endl; // Call myMax for double
    cout << myMax<char>('g', 'e') << endl;   // Call myMax for char
    return 0;
}
```

#### Function & Operator Overloading

Overloading allows you to provide _multiple_ definitions for the same operator or method in the same scope. Functions must have _different_ types and/or argument counts.

- The compiler uses overload resolution to distinguish among the overloaded functions.
```cpp
#include <iostream>
using namespace std;

void display(int);
void display(float);
void display(int, float);

int main() {
    int a = 5;
    float b = 5.5;
    display(a);
    display(b);
    display(a, b);
    
    return 0; 
}

void display(int var) {
    cout << "Integer number: " << var << endl;
}

void display(float var) {
    cout << "Float number: " << var << endl;
}

void display(int var1, float var2) {
    cout << "Integer number: " << var1;
    cout << " and float number: " << var2;
}
```

Built-in operators can be overloaded as well with user-created types.

- Use the `operator` keyword alongside the symbol to overload.
- The overloaded operator is a function.
    - As such, it has a parameter list and return type.

![[_assets/images/Disassembled-Cpp-Overloaded-Operator-Types.png]]

```cpp
class Box {
public:
    double getVolume(void) {
        return length * breadth * height;
    }

    void setLength(double len) {
        length = len;
    }

    void setBreadth(double bre) {
        breadth = bre;
    }

    void setHeight(double hei) {
        height = hei;
    }

    // Overloaded + operator to add two Box objects
    Box operator+(const Box& b) {
        Box box;
        box.length = this->length + b.length;
        box.breadth = this->breadth + b.breadth;
        box.height = this->height + b.height;
        return box;
    }

private:
    double length;  // Length of a box
    double breadth; // Breadth of a box
    double height;  // Height of a box
};
```


#### `This` Pointer

`This` refers to this particular instance of an object. The `this` pointer allows _each object_ to maintain its own unique data members.

- We may have many instances of the same object; we need a way to keep members separate, so each object has its own data members.
- All objects share the same methods.

The compiler creates a `this` pointer to facilitate the process of each object having unique data members. It is passed as a hidden argument to all non-static function calls.

- It is a private value that holds the memory address of the object.
- If a local variable has the same name as a data member, you can use the `this` pointer explicitly to access the object's data member of the same name.

#### Namespaces

Namespaces create logical groups to organize code and avoid collisions.

- Without namespaces, entities would have _global_ scope, but namespaces provide a more narrow scope.
- Particularly relevant when using multiple libraries.
- Namespaces can be declared in header files.
- Within each scope, a name corresponds to one entity, but with namespaces, functions or members with the same name can be referenced via the namespace.

The `std` namespace contains all C++ standard library types and functions, as well as those nested in namespaces within `std`.

```cpp
#include <iostream>
using namespace std;

// Variable created inside namespace
namespace first {
    int val = 500;
}

// Global variable
int val = 100;

int main() {
    // Local variable
    int val = 200;
    
    // Access variables from outside the namespace using the scope operator ::
    cout << first::val << '\n';

    return 0; 
}
```

#### Exceptions

C++ allows you to implement `try`, `throw`, and `catch` expressions to gracefully handle exceptions.

- A `try` block encloses code that may throw an exception.
    - This is the code it will attempt to execute.
- The `throw` keyword in the `try` block signals an exception condition.
    - An error condition must be thrown.
- You can throw something, such as a standard exception, to signal an error, and the exception handler can catch it.
- `catch` blocks handle the exception.
    - Consists of one or more blocks that execute based on the exception type.
    - Can translate it to another type or rethrow a different exception.

```cpp
MyData md;
try {
    // Code that could throw an exception
    md = GetNetworkResource();
}
catch (const networkIOException& e) {
    // Code that executes when an exception of type
    // networkIOException is thrown in the try block
    // ...
    // Log error message in the exception object
    cerr << e.what(); 
}
catch (const myDataFormatException& e) {
    // Code that handles another exception type
    // ...
    cerr << e.what();
}

// The following syntax shows a throw expression
MyData GetNetworkResource() {
    // ...
    if (IOSuccess == false)
        throw networkIOException("Unable to connect");
    if (readError)
        throw myDataFormatException("Format error");
}
```

##### Structured Exception Handling (SEH)

Designed for C
- Use the `/EH` option if compiled.
- Exception handlers are in a linked list on the stack.
    - Can be overwritten maliciously.
- Allows code to take control of the program when it would have otherwise crashed.
    - If an exception occurs, execution will go to the head of SEH and walk the possible handlers so the program can be gracefully closed.

**Grammar**
```cpp
// try-except-statement:
__try // compound-statement
__except // (expression) compound-statement  
```

#### Static Members

If a data member is declared _static_, there will be only one copy of the data for all objects of the class.

- They are not part of objects.
- If a member function is static, no `this` pointer is created.

#### Inheritance and Overloading

Inheritance allows for the creation of an "is a" relationship between a base class and a subclass.

- Child classes inherit methods and data from their parent class.
- Multiple inheritance from base classes is possible.

A child inherits _all_ functions and _all_ data belonging to its parent class.

- There are access restrictions: public, protected, and private.
    - Private members are not inherited. Protected members cannot be accessed from outside classes.
- Constructors, destructors, overloaded operators, and friend functions are _not_ inherited.

Usually, the child class will also have its own unique data and functions.

- Inheritance chains allow for subclasses to inherit from other subclasses.
- This allows for more logical code organization.
- Code functionality can be reused and implemented more easily.
    - No need to reinvent the wheel; just inherit from a base class.

#### Polymorphism

Polymorphism often involves a hierarchy of classes united via inheritance, allowing for the overloading of existing functions as needed.

- **Static Binding**: A function call is fixed at compile time, prior to execution.
    - Examples: Function overloading, operator overloading.
- **Dynamic Binding**: This is done dynamically at runtime.
    - Occurs if a function is _overridden_.
    - Enabled by implementation details such as vtables and RTTI.

#### Virtual vs. Non-virtual Functions

_Virtual_ functions are responsible for some of the _polymorphism_ in C++.

- Virtual functions can be _overridden_ or redefined by a subclass.
    - Execution is determined at runtime.
    - The subclass shares the same name as the base class.
    - Virtual functions don't have to be overridden.

Non-virtual functions _cannot_ be overridden.

- These are determined at compile time.

If a class has a virtual function, then the object will have the virtual pointer (VPTR) inserted as a data member of the class, pointing to the vtable.

**Example: Non-virtual function**
```cpp
class A {
public: 
    void foo() {
        printf("Class A\n");
    }
};

class B : public A {
public:
    void foo() {
        printf("Class B\n");
    }
};

void g(A& arg) {
    arg.foo();
}

int main(int argc, char* argv[]) {
    B b;
    A a;
    g(b);
    return 0;
}
```

**Example: Virtual function**
```cpp
class A {
public: 
    virtual void foo() {
        printf("Class A\n");
    }
};

class B : public A {
public:
    virtual void foo() {
        printf("Class B\n");
    }
};

void g(A& arg) {
    arg.foo();
}

int main(int argc, char* argv[]) {
    B b;
    A a;
    g(b);
    return 0;
}
```

- Polymorphism, encapsulation, and inheritance make C++ a unique and powerful language.
- The `virtual` keyword is crucial for methods to be overridden.
- Classes must be instantiated.

## References 

- [C Vtables in IDA Pro](#https://rioasmara.com/2020/08/23/ida-pro-c-vtable/)
- [Binary I/O: Object Serialization](#https://faculty.cs.niu.edu/~mcmahon/CS241/Notes/binary_io.html)
- [Ghidra Disassembling](#http://hwreblog.com/projects/ghidra.html)

## Revision History

- **2024-09-10**: Entry created.