up:: [[Cybersecurity/Reverse Engineering & Malware Analysis/Software Reverse Engineering (SWRE)]]

# Process Memory

Process memory in the context of Software Reverse Engineering (SRE) involves analyzing the memory space allocated to a running process to understand its behavior, identify vulnerabilities, and extract useful information. This analysis is crucial for understanding how software operates at runtime and for uncovering hidden or obfuscated functionality.

## Key Features

- **Memory Dumping**: Capturing the contents of a process's memory for offline analysis.
- **Dynamic Analysis**: Observing and interacting with a running process to understand its behavior.
- **Memory Forensics**: Investigating memory to identify malicious activities or recover data.
- **Code Injection Detection**: Identifying unauthorized code that has been injected into a process's memory space.

## Process vs. Program

The key distinction between a process and a program is: 
- A *program* is simply a series of instructions, static, that exists on disk and meta information to tell the OS what to do. 
- A *process* is an abstract container that holds all the resources that are used during the execution of the program.

### Process

A process is defined as an instance of a running program containing two main components:

1. **Kernel Object**:
    - Used by the OS to manage the process
    - Maintains information about the process
2. **Address Space**:
    - Contains all the executable and dynamic link library code and data
    - Includes memory like heap allocations and thread stacks

Additionally, a process includes:

- **Private Virtual Address Space**: The executable program is mapped into this space.
- **Listing of Open Handles**: Keeps track of resources like files and devices.
- **Security Context**: Stored in objects called access tokens.
    - Threads can also have access tokens to impersonate the security context of other processes.
- **Process ID**: A unique identifier for the process.
- **Synchronization Object**: Used for coordinating the execution of threads.
- **At Least One Thread of Execution**: Every process must have at least one thread.

#### Tools

##### Process Explorer

Process Explorer provides extensive details about processes and threads, surpassing many other available tools. Some of its features include:

- **Process Security Token**: Displays security information for processes.
- **Highlighting**: Uses color coding for different types of processes.
- **Start Time**: Shows the start time for processes and threads.
- **Memory-Mapped Files**: Provides a complete list, not just DLLs.
- **Suspend/Resume**: Ability to suspend or resume a process or a thread.
- **Kill Thread**: Ability to terminate an individual thread.

It offers a quick way to obtain all necessary information in a compact location, including:

- **Process Tree**: Visual representation of process hierarchy.
- **Open Handles**: Lists all handles in a process, including unnamed ones.
- **DLLs and Memory-Mapped Files**: Lists all DLLs and memory-mapped files in a process.
- **Thread Activity**: Displays thread activity within a process.
- **Thread Stacks**: Shows user-mode and kernel-mode thread stacks currently in use.
- **Memory Manager Details**: Provides details such as peak commit charge and kernel memory (paged and nonpaged).
- **Pool Limits**: Displays pool limits, not just size.

### Programs on Disk

When a program is executed, the following steps occur:

1. **Process Object Creation**: The kernel creates a process object to represent the program.
2. **File Type Determination**: The OS determines the file type.
3. **Library Mapping**: Any needed libraries are mapped into virtual memory.
4. **PE File Parsing**: The PE file format is parsed to determine the initial entry point in memory.

#### Image Loader

The image loader is part of `ntdll.dll` and operates in user-mode, not kernel-mode:

- **Initialization**: `ntdll.dll` is always the first piece of code to run in user mode for a new application.
- **User-Mode Initialization**: The image loader initializes user-mode for the PE, creating the initial heap setting.
- **Import Table Parsing (IAT)**:
    - Discovers all required DLLs by parsing the import table.
    - Recursively parses the IAT for each subsequent DLL, as each DLL may have its own import table.
- **Export Table Parsing**: Verifies that all required functions are present by parsing the export tables.
- **Execution Continuation**: After the process is created, the image loader calls a special API that uses a context frame located on the stack to continue execution. The kernel creates this context frame, providing the entry point of the application.

#### Threads

Threads are essential for execution, with at least one thread required for a process to run. Each thread has:

- **CPU Registers**: Contains the processor state.
- **Two Stacks**: One for kernel mode and one for user mode.
- **Thread-Local Storage (TLS)**: A private storage area that DLLs and subsystems can utilize.
- **Thread ID**: A unique identifier.
- **Security Context (Token)**: May have its own security context. Multi-threaded server applications can impersonate tokens of clients they serve.

#### Context

The combination of stacks, registers, and private storage area for a thread is known as the _**thread's context**_. This context varies based on the specific machine architecture that Windows runs on.

- **`GetThreadContext` Function**: Provides access to architecture-specific information, known as the CONTEXT block.
- **32-bit and 64-bit Contexts**: On a 64-bit Windows system, threads for a 32-bit application will have contexts for both 32-bit and 64-bit. _Wow64_ is used to switch the application between 32-bit and 64-bit as needed.

Threads share all the process's resources, including the virtual address space. This means:

- **Read-Write Access**: All threads have read-write access to the process's virtual address space.
- **Isolation**: Threads cannot reference another process's virtual address space unless that process makes its private address space available as a shared memory section.

#### Virtual Memory (Virtual Address Space)

- **Linear Address Space**:
    - **32-bit**: `0x0 - 0xFFFFFFFF` (2 GB range)
    - **64-bit**: `0x000'00000000 - 0x7FF'FFFFFFFF` (8 TB range)
- **Address Translation**: The processor translates virtual addresses (VA) to physical addresses. Programmers do not need to manage this.
- **Benefits**:
    - Programs can use a contiguous range of memory addresses, even if not contiguous in physical memory.
    - Allows programs to access more memory than is physically available.
    - Virtual addresses for each process are isolated.

Windows implements virtual memory using a flat, linear address space, creating the illusion of a large, private address space for each process. The memory manager maps virtual addresses to physical addresses at runtime to ensure processes do not interfere with each other.

- **Memory Mapping**:
    - **Paging**: Maps virtual addresses to physical addresses using pages.
    - **Segmentation**: RAM is segmented into pages, loaded into and out of RAM on demand.
    - **Benefits**:
        - Reduces load time and RAM usage.
        - Slows access due to potential page faults (lazy loading).

**32-bit x86**:

- Total virtual space has a theoretical hard limit of 4 GB.
- **Process Address Space**: `0x00000000 - 0x7FFFFFFF` for processes.
- **OS System Memory**: `0x80000000 - 0xFFFFFFFF` (can be adjusted to give 3 GB to processes).

**64-bit Windows**:

- Allows up to 128 TB on Windows 8.1+ (hardware limitations).
- Theoretical limit up to 16 EB (1 EB = 1,048,576 TB).

Processes use a page lookup table to map virtual memory to physical addresses. Virtual memory is managed in pages, not bytes, with specific rules for memory access and usage.

- **Memory Access Rules**:
- 
    - Different sections in the PE file format inform the processor how to treat memory.
    - At load time, the memory manager sets access rights (Read, Write, Execute) based on section headers.
    - Each page indicates kernel mode, user mode, and access rights.
    - Sections often begin on a fresh page.

##### Paging

Paging is a method to manage memory, handled by the memory manager without the involvement of processes or threads. It allows physical memory to be used for other processes or the system.

- **Secondary Storage**: Enables secondary storage devices to be used as primary storage (RAM), though at a cost of speed.
- **Page Size**: Pages come in same size blocks, allowing for contiguous virtual address space with non-contiguous physical memory.

**Page Faults**:

- Occur when a program tries to access a page outside of RAM.
- The OS loads the needed page, which is computationally expensive as it might require writing pages to secondary storage.

**Access Rules**:

- Pages in system space can only be accessed from kernel mode.
- All pages in user address space are accessible in user mode.
- Read-only pages are not writable in any mode.
- Processors support no-execute memory protection.

##### Executing a Program

To execute a program, you need to know where it is loaded in memory. Understanding the PE file format helps discover the execution point.

- **PE File Format**:
    - **`IMAGE_NT_HEADERS --> IMAGE_OPTIONAL_HEADER32`**:
        - **`AddressOfEntryPoint`**: Defines the start point (not the same as `main`). This is a _**Relative Virtual Address (RVA)**_.
        - **`ImageBase`**: Defines where the program will be loaded into memory, default is **`0x400000`**.

To find the entry point on disk:

1. **Find the Section**: Locate the section where the entry point falls.
    - View **`SECTION_HEADER --> VirtualAddress`**.
2. **Calculate Raw Offsets**:
    - The **`AddressOfEntry`** is an RVA from **`ImageBase`**.
    - Subtract **`VirtualAddress`** from **`AddressOfEntry`** to obtain raw offsets.
        - Example: **`0x17e0h - 0x1000h = 0x7e0h`**.
3. **Add Raw Data Pointer**:
    - From **`SECTION_HEADER`**, add the **`PointerToRawData`** value.

A hex editor can be used to view members of structures for the PE file format. The values are hexadecimal opcodes, such as:

- `C3` = `return`
- `55` = `push ebp`


## Impact

- **Vulnerability Discovery**: Helps in identifying security vulnerabilities that manifest during runtime.
- **Malware Detection**: Provides insights into the behavior and techniques used by malware.
- **Debugging and Optimization**: Aids in debugging software and optimizing its performance by understanding runtime behavior.
- **Forensic Analysis**: Assists in forensic investigations by recovering data and understanding malicious activities.

## Defense Mechanisms

- **Memory Protection**: Implementing measures to protect memory regions from unauthorized access.
- **Address Space Layout Randomization (ASLR)**: Randomizing memory addresses to make it harder for attackers to predict the location of specific processes.
- **Data Execution Prevention (DEP)**: Preventing execution of code from non-executable memory regions.
- **Anti-Tampering Techniques**: Detecting and preventing unauthorized modifications to process memory.

## Exploitable Mechanisms/Weaknesses

If not properly managed, process memory can be exploited to inject malicious code, extract sensitive information, or bypass security mechanisms. Over-reliance on automated tools without adequate human oversight might result in incomplete or incorrect analysis.

## Revision History

- **2024-09-10**: Entry created.
- **2024-12-5**: Refactored for clarity. 
