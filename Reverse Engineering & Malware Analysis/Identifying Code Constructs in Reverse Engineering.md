up:: [[Reversing Object-Oriented C++|Reversing Object-Oriented C++]]

# Identifying Code Constructs in Reverse Engineering

## Examples
---

### example.cpp
```cpp
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    int i_array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    char c_array[25] = "hello ";
    char *cptr = &c_array[6];
    int temp = 0;
    for (int i = 0; i < 5; i++) {
        temp = i_array[i + 5];
        temp += i_array[i];
        cptr += sprintf(cptr, "%d ", temp);
    }
    printf("%s\n", c_array);
}
```

### if-statement.c
```c
#include <stdio.h>
int main(void) {
    int a = 0;
    int b = 5;
    if (a > b) {
        puts("a is greater than b");
    } else {
        puts("a is not greater than b");
    }
}
```

### if-statement2.c
```c
#include <stdio.h>
int main(void) {
    int a = 0;
    int b = 5;
    int c = 99;
    if (a > b && a < c) {
        puts("a is greater than b and less than c");
    } else if (a > c) {
        puts("a is greater than c");
    } else {
        puts("a is less than c");
    }
}
```

### loops.c
```c
#include <stdio.h>
void doWhileLoop(void) {
    int x = 99;
    while (x > 0) {
        printf("%d\n", x);
        x--;
    }
}
int main(void) {
    size_t i;
    for (i = 0; i < 10; i++) {
        printf("%d\n", i);
    }
    doWhileLoop();
}
```

### nested-if.c
```c
#include <stdio.h>
int main(void) {
    int x = 0;
    int y = 1;
    int z = 0;
    puts("Enter a number:");
    scanf("%d", &z);
    if (x < 10) {
        if (z > 0)
            puts("x < 10 and z > 0");
        else
            puts("x < 10 and z <= 0");
    } else {
        if (z > 0)
            puts("x >= 10 and z > 0");
        else
            puts("x >= 10 and z < 0");
    }
}
```

### pointer.c
```c
#include <stdio.h>
int main(int argc, char **argv, char **envp) {
    int i;
    for (i = 0; i < argc; i++) {
        printf("--%s\n", *argv);
        argv++;
    }
}
```

### switch.c
```c
#include <stdio.h>
void large_switch(void) {
    int i = 3;
    switch (i) {
        case 0:
            puts("You entered 0");
            break;
        case 1:
            puts("You entered 1");
            break;
        case 2:
            puts("You entered 2");
            break;
        case 3:
            puts("You entered 3");
            break;
        default:
            puts("I guess I don't care what you entered");
    }
}
int main(void) {
    int i = 0;
    puts("Enter a value:");
    scanf("%d", &i);
    switch (i) {
        case 0:
            puts("You entered 0");
            break;
        case 1:
            puts("You entered 1");
            break;
        case 2:
            puts("You entered 2");
            break;
    }
    large_switch();
}
```

### Makefile
A Makefile to group compile each of the source files is provided below.

```bash
# Compiler for C and C++ files
CC = gcc
CXX = g++

# Compiler flags
CFLAGS = -Wall -Wextra -O2
CXXFLAGS = -Wall -Wextra -O2

# List of C source files
C_SOURCES = if-statement.c if-statement2.c loops.c nested-if.c pointer.c switch.c

# List of C++ source files
CPP_SOURCES = example.cpp

# Generate list of binaries from source files
C_BINARIES = $(C_SOURCES:.c=.exe)
CPP_BINARIES = $(CPP_SOURCES:.cpp=.exe)

# Default target to build all binaries
all: $(C_BINARIES) $(CPP_BINARIES)

# Rule to build C binaries
%.exe: %.c
    $(CC) $(CFLAGS) -o $@ $<

# Rule to build C++ binaries
%.exe: %.cpp
    $(CXX) $(CXXFLAGS) -o $@ $<

# Clean up generated binaries
clean:
    rm -f $(C_BINARIES) $(CPP_BINARIES)
```

- _Note: If you get a Makefile missing separator error, you can use the command_ `cat -e -t -v makefile_name` _which will show the presence of tabs with `^I` and line endings with `$`._

## Revision History

- **2024-12-4**: Entry added.
- **2024-12-5:** Added Makefile code to compile each of the source files into binaries. 