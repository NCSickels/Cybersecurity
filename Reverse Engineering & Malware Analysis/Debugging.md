up:: [[Cybersecurity/Reverse Engineering & Malware Analysis/Software Reverse Engineering (SWRE)]]

# Debugging

Debugging involves identifying, analyzing, and resolving bugs or defects in software. The primary goal is to ensure that the software operates as intended by fixing issues causing incorrect or unexpected behavior.

## Key Features

- **Error Detection**: Identifying the presence of bugs or defects in the software.
- **Root Cause Analysis**: Determining the underlying cause of the identified issues.
- **Code Correction**: Modifying the code to fix the identified issues.
- **Testing**: Verifying that the fixes resolve the issues without introducing new problems.

## Understanding Source-Level vs. Low-Level

### Low-Level

- Debugs at the Assembly level rather than on source code.
- Able to set breakpoints on instructions, enabling examination of memory, registers, the stack, etc.
- Useful for understanding what compilers do with your code.

### Source-Level

- Allows programmers to debug and correct issues while creating software.
- Enables setting breakpoints on specific lines of code.
- Frequently built into an IDE.

## Kernel-Mode vs. User-Mode

### User-Mode

- Reverse engineering (RE) typically concerns itself with programs run in user-mode.

### Kernel-Mode

- Possible to reverse engineer kernel-mode, but it is more challenging.
    - Exploits in kernel-mode are more powerful.
    - Drivers usually run in kernel-mode and need to be debugged there.
    - Requires learning new debugging commands.
- Kernel debugging often involves one computer or VM debugging another.
    - Complicated to set up and slow to perform.
    - One machine acts as the debugger, the other as the 'debuggee'.
    - Can be done with tools like WinDbg or VirtualKD.
    - Can be done remotely over a local network with VMs.
        - More complicated setups are possible, such as using a COM port manually.

## Refresher: Processes & Threads

### Program

- An inactive sequence of instructions existing on a hard disk that a computer follows to perform a specific task. 
- Written in programming languages and can be interpreted, compiled, or assembled into machine-readable format.a

### Process

- An inert container with all resources for a live instance of a process object that is running.
- Each process has its own private virtual address space, isolated from the system and other processes.
- Contains a list of open handles to different system resources, which thread(s) in the process can use.
- Each process has its own process ID (PID).
- Can load as many or as few DLLs/modules as needed.
- Must have at least one thread of execution.
- Has its own stack and heap space.

### Thread

- Executes within a process.
- Each thread has a unique thread ID (TID).
- Thread local storage (TLS) can be used by DLLs, run-time library, and subsystems.
- Windows can switch execution to other threads at any time.
- A thread has a context data structure that indicates the state of the processor, stack space, etc.

### Context Switch

- Thread interruption, switching the CPU from one thread to another.
- The CPU captures and restores the CPU state before and after the thread interruption.

### Handle

- Handles come from handle tables.
- An entry in the handle table has a pointer to an underlying object.
- The handle entry also specifies what kind of operations can be performed on the object.

## Using a Debugger

There are two primary ways to utilize a debugger:

1. **Attach to a Running Process**:
    
    - Insert a breakpoint, pausing execution to issue commands, etc.
    - Once resumed, execution continues until a breakpoint, exception, or program termination is reached.
2. **Open an Executable**:
    
    - Load the program into memory.
    - Execution is paused at the start, allowing breakpoints to be set.
    - Can be done in a program GUI or command line.

### Stepping Through a Program

#### Single-Stepping

- Execute one instruction at a time, pausing after each instruction.
    - Inspect registers, issue commands, etc., after each instruction.
    - Can be time-consuming and tedious.
    - Stepping-into and stepping-over both do this; the difference is when you get to a call.
    - In source mode, single-stepping may execute more than one assembly instruction at times.

#### Stepping-Over

- Bypass irrelevant or unimportant items.
    - Some calls occur repeatedly and offer no insights.
    - When stepping over a function call, you are taken to the instruction after the function returns, executing the function and all sub-functions.

#### Stepping-Into

- Step into a function, going through it instruction by instruction.
    - Some functions can lead to multiple calls, loops, etc.

### Breakpoints

Breakpoints allow you to pause the execution of a program to inspect its contents, such as memory, registers, upcoming instructions, and other calls leading to that point. Breakpoints can be set at both the CPU level (hardware) and via software.

#### Software Execution Breakpoints

- Programs loaded into memory can be modified to create breakpoints.
    - The debugger rewrites memory to add `0xcc` or `int 3` assembly instructions.
        - `int 3` can be used in project programs for debugging and removed when done.
    - When a breakpoint is reached, the program pauses and transfers control to the debugger.
        - The user can inspect memory, registers, etc.
        - Software breakpoints deal with memory and may overwrite valuable data.
        - Self-modifying code may erase breakpoints.

#### Hardware Execution Breakpoints

- Useful when software breakpoints do not work, such as with read-only memory locations or breaking on data access.
    - Can be set to break when an important memory location is accessed.
- Use special debug registers to break at the CPU level.
    - Can specify conditions like read, write, or execute.
    - Hardware breakpoints are limited in number.

#### Conditional Breakpoints

- Execution pauses only if certain conditions are met.
- Useful for stopping execution under specific circumstances.
- Can slow down the program if the instruction is accessed frequently and the condition needs to be evaluated; use sparingly.

### Exceptions

Exceptions are the primary way a debugger gains access to a running program. Debuggers typically get two opportunities to handle an exception:

#### First Chance Exception

- Occurs when the debugger is attached to a process.
- The debugger is given the first chance to control the exception.
- The debugger can handle the exception or pass it to the program.
- If the program has a registered exception handler, it is given a chance after the debugger.
    - Example: The program is about to segmentation fault.

#### Second-Chance Exceptions

- If the program does not handle the exception, the debugger gets a second chance.
    - Without debugging, the program would have crashed.
    - If the debugger cannot resolve the exception, the program will terminate.
- It is often safe to ignore first-chance exceptions if your goal is to find bugs.
    - Can be useful for bug hunting.

## Not vs Negate Instructions in a Debugger
-----

```cpp
#include <stdio.h>
#include <windows.h>

int main(int argc, char argv[], char envp[]) 
{
	char* var = NULL;
	_asm {
		int 3
		mov eax, 0x44
		mov ebx, 0
		sub ebx, eax
		// 0 - 0x44 = 0xFFFFFFBC
		not ebx
		// !(0xFFFFFFBC) = 0x43
		inc ebx
		// inc 0x43 = 0x44
		
		int 3
		mov eax, 0x44
		mov ebx, 0
		sub ebx, eax
		// 0 - 0x44 = 0xFFFFFFBC
		neg ebx
		// -(FFFFFFBC) = 0x44
		inc ebx
		// inc 0x44 = 0x45
		skip:
		nop
	}
printf("\n\n");
// printf(buffer);
printf("Bye!");
}
```


## Problem Addressed

Debugging addresses the problem of software defects that can lead to incorrect functionality, crashes, or security vulnerabilities. It helps ensure that software operates correctly and reliably.
## Implications

The strategic use of debugging can lead to higher software quality, improved user satisfaction, and reduced maintenance costs. It can also enhance the security and performance of the software by identifying and fixing vulnerabilities and inefficiencies.

## Impact

- **Improved Software Quality**: Ensures that the software functions as intended and meets user requirements.
- **Enhanced Security**: Identifies and fixes security vulnerabilities that could be exploited by attackers.
- **Increased Reliability**: Reduces the likelihood of software crashes and other failures.
- **Optimized Performance**: Identifies and resolves performance bottlenecks.

## Defense Mechanisms

- **Automated Testing**: Using automated tests to quickly identify defects during development.
- **Static Analysis Tools**: Analyzing code without executing it to identify potential issues.
- **Dynamic Analysis Tools**: Analyzing code during execution to identify runtime issues.
- **Version Control Systems**: Tracking changes to code to facilitate debugging and rollback.

## Exploitable Mechanisms/Weaknesses

If not properly managed, debugging can introduce new bugs or security vulnerabilities. Over-reliance on automated tools without adequate human oversight might result in missed or misinterpreted issues. Additionally, debugging information can sometimes be exploited by attackers to gain insights into the software's operation.

## Current Status

Debugging is an essential part of the software development lifecycle, with advanced tools and techniques continually being developed to improve its effectiveness. It is widely used in all stages of software development to ensure the quality, security, and performance of software. Many organizations now have dedicated teams and processes focused on debugging to address various aspects of software maintenance and improvement.

## Additional References

- [WinDbg Cheat Sheet](https://theartofdev.com/windbg-cheat-sheet/) 

## Revision History

- **2024-09-10**: Entry created.
- **2024-12-5**: Refactored for clarity. 