up:: [[Cybersecurity/Reverse Engineering & Malware Analysis/Software Reverse Engineering (SWRE)|Software Reverse Engineering (SWRE)]]

# Windows API

The Windows API (Application Programming Interface) is a set of functions and protocols provided by Microsoft Windows operating systems that allows applications to interact with the system's hardware and software components. It provides a standardized way for software developers to access system resources and perform various tasks.

## Key Features

- **System Services**: Provides access to core system services such as file management, device input/output, and process control.
- **User Interface**: Functions for creating and managing graphical user interfaces, including windows, menus, and controls.
- **Graphics and Multimedia**: APIs for handling graphics, audio, and video operations.
- **Networking**: Functions for network communication and internet protocols.
- **Security**: APIs for managing security features such as authentication, encryption, and access control.

### Key Terms

- **Windows API Functions**: Documented subroutines that are callable, e.g., `CreateProcess`, `CreateFile`.
    
- **Native System Services (system calls)**: Undocumented, underlying services in the OS, callable from user mode.
    
    - Example: `NtCreateUserProcess` is an internal service called by `CreateProcess`.
- **Kernel Support Functions (Routines)**: Subroutines inside Windows that are called only from Kernel Mode, e.g., `ExAllocatePoolWithTag`.
    
- **Windows Services**: Processes that the Windows service control manager starts.
    
- **DLL (Dynamic-Link Libraries)**: Set of callable subroutines joined as one binary file, e.g., `Kernel32.dll`, `Msvcrt.dll`.
    
    - Loaded dynamically by an application.
    - Only one in-memory copy of the DLL is needed for applications using it.
- Microsoft Developers Network (MSDN): [MSDN](vscode-file://vscode-app/c:/Users/nsickels/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) - Excellent resource for research into APIs or Windows internals.

### Types and Hungarian Notation

- Windows uses terms like `WORD` and `DWORD` to signify 16-bit/32-bit values.
    - This differs from programming languages, which use types such as `int`, `short`, or `unsigned int`.
- **Hungarian Notation**:
    - Example: `LPVOID` as a type.
    - Prefix notation used to identify a variable's type.
    - Example: `LPCTSTR lpApplicationName` - long pointer to constant.
    - Example: `TCHAR string` - wide-character string.

### Objects in Windows

- A process is an instance of a process object type.
- When a process creates or opens an object by name, it gets a handle representing access to the object.
- In Windows OS, a kernel _object_ is a single, run-time instance of a statically-defined data type.
- Object attributes define the object's state.
    - For a process object type, attributes include a process ID, base scheduling priority, pointer to an access token object, etc.
    - Object methods provide subroutines to manipulate or interact with an object.
- Services allow data to be put into or retrieved from objects.
    - Direct reading or modification of data in an object is not allowed.
- Many, but not all, data structures in Windows are objects.
    - Objects must be shared, protected, and made visible to user-mode programs.

### Handles

- A handle is a reference to an instance of an object.
    - Handles provide access to menus, windows, files, directories, and more.
- The OS opens or creates handles.
- Similar to C-style pointers:
    - Does not support pointer arithmetic.
    - In disassembly, a handle resembles a pointer.
- Tools like Process Hacker can be used to view handles:
    - Double-click process -> select handles.
- Handles can be named or unnamed.
- Processes can inherit handles at process creation time:
    - Requires the inherit handle flag on `CreateProcess`.
    - Handle must also be marked as inheritable.
- No differences between file handles, event handles, or process handles.
- `-1` refers to the handle/process itself.

#### Why Handles?

- Handles are faster. When a process creates an object by name, it gets a handle that provides access to that object.
- Referring to the object by the handle is faster because it skips the name lookup process, acting as an indirect pointer.
    - Indirection prevents programs from directly interacting with the system's data structures.
- User-mode processes need a handle to an object before threads can use that object.
- The object manager exclusively creates and finds handles, ensuring the security profile for the caller allows the operation.

### VirtualAlloc Function

- Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.
- To allocate memory in the address space of another process, use the `VirtualAllocEx` function.
- When creating a malicious process to run the payload in the memory of a process, a memory buffer for the payload is needed. Use the `VirtualAlloc` function for this purpose.
- [Other examples of VirtualAlloc](vscode-file://vscode-app/c:/Users/nsickels/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html)
- [Related examples of handles](vscode-file://vscode-app/c:/Users/nsickels/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html)

#### Syntax
```cpp
LPVOID WINAPI VirtualAlloc(
	_In_opt_ LPVOID lpAddress,
	_In_     SIZE_T dwSize,
	_In_     DWORD  flAllocationType,
	_In_     DWORD  flProtect
);

```

#### VirtualAlloc - Parameters

- **`lpAddress [in, optional]`**:
    
    - The starting address of the region to allocate. If reserving memory, the address is rounded down to the nearest multiple of the allocation granularity. If committing already reserved memory, the address is rounded down to the next page boundary. Use `GetSystemInfo` to determine the size of a page and the allocation granularity. If **NULL**, the system determines where to allocate the region.
    - If the address is within an uninitialized enclave (not initialized by `InitializeEnclave`), `VirtualAlloc` allocates a page of zeros for the enclave at that address. If the address is within an initialized enclave, the allocation fails with `ERROR_INVALID_ADDRESS`.
- **`dwSize [in]`**:
    
    - The size of the region in bytes. If `lpAddress` is **NULL**, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from `lpAddress` to `lpAddress + dwSize`. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.
- **`flAllocationType [in]`**:
    
    - The type of memory allocation. This parameter must contain one of the following values:
        - **MEM_COMMIT** - `0x00001000`:
            - Allocates memory charges for the specified reserved memory pages. Guarantees that when the caller initially accesses the memory, the contents will be zero. Physical pages are not allocated until the virtual addresses are accessed.
            - To reserve and commit pages in one step, call `VirtualAlloc` with `MEM_COMMIT | MEM_RESERVE`.
            - Committing a specific address range with `MEM_COMMIT` without `MEM_RESERVE` and a non-NULL `lpAddress` fails unless the entire range has already been reserved, resulting in `ERROR_INVALID_ADDRESS`.
            - Committing a page that is already committed does not cause the function to fail.
            - If `lpAddress` specifies an address within an enclave, `flAllocationType` must be `MEM_COMMIT`.
        - **MEM_RESERVE** - `0x00002000`:
            - Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk. Reserved pages can be committed in subsequent calls to `VirtualAlloc`. To reserve and commit pages in one step, call `VirtualAlloc` with `MEM_COMMIT | MEM_RESERVE`. Other memory allocation functions, such as `malloc` and `LocalAlloc`, cannot use a reserved range of memory until it is released.


#### VirtualAlloc - Syntax

```cpp
BOOL WINAPI CreateProcessAsUser(
	_In_opt_ HANDLE                 hToken,
	_In_opt_ LPCTSTR                lpApplicationName,
	_In_opt_ LPTSTR                 lpCommandLine,
	_In_opt_ LPSECURITY_ATTRIBUTES  lpProcessAttributes,
	_In_opt_ LPSECURITY_ATTRIBUTES  lpThreadAttributes,
	_In_     BOOL                   bInheritHandles,
	_In_     DWORD                  dwCreationFlags,
	_In_opt_ LPVOID                 lpEnvironment,
	_In_opt_ LPCTSTR                lpCurrentDirectory, 
	_In_     LPSTARTUPINFO          lpStartupInfo,
	_Out_    LPPROCESS_INFORMATION  lpProcessInformation
);
```

```cpp
typdef struct _STARTUPINFOA_ {
DWORD     cb;
LPSTR     lpReserved;
LPSTR     lpDesktop;
LPSTR     lpTitle;
DWORD     dwX;
DWORD     dwY;
DWORD     dwXSize;
DWORD     dwYSize;
DWORD     dwXCountChars;
DWORD     dwYCountChars;
DWORD     dwFillAttribute;
DWORD     dwFlags;
WORD      wShowWindow;
WORD      cbReserved2;
LBYTE     lpReserved2;
HANDLE    hStdInput;
HANDLE    hStrOutput;
HANDLE    hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
```

```cpp
typdef struct _PROCESS_INFORMATION {
HANDLE     hProcess;
HANDLE     hThread;
DWORD      dwProcessId;
DWORD      dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION
```

```cpp
// Impersonate client to ensure access to executable file.
if (!ImpersonateLoggedOnUser(hToke))
	goto Cleanup;
// Initialize the STARTUPINFO structure.
// Specify that the process runs in the interactive desktop

ZeroMemory(&si, sizeof(STARTUPINFO));
si.cb = sizeof(STARTUPINFO);
si.lpDesktop = TEXT("winsta0\\default");

// Launch the process in the client's logon session

bResult = CreateProcessAsUser(
hToken,         // Client's access token 
NULL,           // file to execute
lpCommandLine,  // command line
NULL,           // pointer to process SECURITY_ATTRIBUTES
NULL,           // pointer to thread SECURITY_ATTRIBUTES
FALSE,          // handles are not inheritable
NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,  // creation flags
NULL,           // pointer to new environment block
NULL,           // name of current directory
&si,            // pointer to STARTUPINFO structure
&pi             // receives information about new process
);
```

```cpp 
#include <windows.h>
#include <stdio.h>
#include <tchar.h>

void _tmain( int argc, TCHAR *argv[] )
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	ZeroMemory( &si, sizeof(si) );
	si.cb = sizeof(si);
	ZeroMemory( &pi, sizeof(pi) );

	if( argc != 2 )
	{
		printf("Usage: %s [cmdline]\n", argv[0]);
		return;
	}

	// Start child process
	if( !CreateProcess( NULL // No module name (cmd line)
		argv[1],         // Command line
		NULL,            // Process handle not inheritable
		NULL,            // Thread handle not inheritable
		FALSE,           // Set handle inheritance to false
		0,               // No creation flags
		NULL,            // Use parent's environment block
		NULL,            // Use parent's starting directory
		&si,             // Pointer to STARTUPINFO struct
		&pi )        // Pointer to PROCESS_INFORMATION struct 
	)
	{
		printf( "CreateProcess failed (%d).\n", 
		GetLastError() );
		return;
	}
	// Wait until child process exits.
	WaitForSingleObject( pi.hProcess, INFINITE );

	// Close process and thread handles.
	CloseHandle( pi.hProcess );
	CloseHandle( pi.hThread );
}
```

```cpp
// Example use case from https://www.jaacostan.com/2022/03/malware-analysis-virtualalloc-function.html
char payload[] = {0x90, 0x90};
int payload_size = 2;
// Now use the VirtualAlloc function to allocate a memory buffer:
VirtualAlloc(0, payload_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
/* 
* In the above function, we mentioned that the starting address is zero/NULL. 
* dwSize, the size of the payload, flAllocationType as MEM_COMMIT and MEM_RESERVE and finally, the flProtect memory region as readable and writeable (PAGE_READWRITE)
*/
```

### Dynamic-Linked Libraries (DLLs)

- **DLL**: A shared library or module.
    
    - All terms are synonymous.
    - A set of callable subroutines linked together as a binary file.
    - Applications can use these subroutines from a DLL.
- **Insights from DLLs**:
    
    - DLLs provide insights into what functions a program may import.
    - **Imports**: Functions used in a program or process from a DLL.
- **Linking a DLL**:
    
    - How a DLL is linked is crucial: statically, at run-time, or dynamically.
- **PE File Header**:
    
    - Contains data on all libraries that will be loaded and all functions used by the program.
    - This is not the case if the function is resolved dynamically, as some are more discrete about imports.
- **DLL Diagram -->** [[Cybersecurity Knowledge Base/_assets/Windows API.canvas|Windows API]]

#### Common DLLs

- **Kernel32**: Key Windows API subsystem for memory, file, registry, process, and I/O operations.
    - Often calls corresponding functions in the native API via **Ntdll**.
- **Advapi32**: Advanced Windows features such as service management, registry, and security calls.
- **User32**: User interface components like windows and menus.
- **Ntdll**: Not loaded directly but via _kernel32_.
    - Interfaces with the kernel to use the native API from _ntoskrnl.exe_.
    - If loaded directly by a program, it indicates the use of functionality not intended for direct use in Windows programs.
- **Msvcrt.dll**: C run-time library.
- **GDI32.dll**: Graphics, fonts, etc.

#### Native Undocumented APIs

- Information can be found [here](vscode-file://vscode-app/c:/Users/nsickels/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html), e.g., _**LdrLoadDll**_.

```cpp
NtSetContextThread(
    IN HANDLE      ThreadHandle,
    IN PCONTEXT    Context
);
```


- **ThreadHandle**: Handle to the Thread Object opened with the `THREAD_SET_CONTEXT` access flag.
    
- **Context**: Context to set to the thread.
    
- _**LdrQueryProcessModuleInformation**_

```cpp
NTSYSAPI
NTSTATUS
NTAPI

LdrQueryProcessModuleInformation(
    OUT PSYSTEM_MODULE_INFORMATION  SystemModuleInformationBuffer,
    IN ULONG                        BufferSize,
    OUT PULONG                      RequiredSize OPTIONAL
);
// Used to enumerate modules loaded with the current process.
```

#### Export Forwarding

- Some functions may appear to be exported from one DLL but are actually from a different DLL.
    
- Forwarding helps Microsoft maintain compatibility across different versions of Windows.
    
- If a function is forwarded, the Export Address Table (EAT) entry will contain a pointer to an ASCII string of the DLL and function names, e.g., `NTDLL.RtlAllocHeap`.
    
- Example: In Windows XP, `HeapAlloc` in `kernel32.dll` is forwarded to `RtlAllocHeap` in `ntdll.dll`.
    
    - `Ntdll.dll` contains the native API, which directly interfaces with the kernel.
    - Some functions act as thin wrappers to `NTDLL` equivalents that perform the actual work.
    - It is recommended to use common Windows API functions instead of low-level native API functions, which may change.

- Tools for analyzing DLLs and export forwarding:
    
    - Dependency Walker
    - PE Studio
    - IDA Pro
    - ProcMon
    - MalAPI.io

## Revision History

- **2024-09-10**: Entry created.
- **2024-12-5**: Refactored for clarity. 