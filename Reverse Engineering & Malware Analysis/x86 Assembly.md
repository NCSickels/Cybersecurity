  up:: [[Cybersecurity/Reverse Engineering & Malware Analysis/Software Reverse Engineering (SWRE)]]

# x86 Assembly

x86 Assembly Language is a low-level programming language for the x86 family of microprocessors. It provides a way to write programs that are closely aligned with the hardware architecture, offering fine-grained control over the system's resources.

## Key Features

- **Low-Level Control**: Provides direct access to the CPU, memory, and hardware peripherals.
- **Instruction Set**: Comprises a rich set of instructions for arithmetic, logic, control flow, and data manipulation.
- **Registers**: Utilizes a set of registers for fast data storage and manipulation.
- **Inline Assembly**: Allows embedding assembly code within high-level language programs for performance-critical sections.

## General Information

- **Compiler**: Converts high-level language into machine code, organized into a series of opcodes.
- **Disassembler**: Converts executable files (machine code) into assembly.
- **Endianness**: Intel machines use _**little endian**_, meaning the least significant byte is first.


![[Cybersecurity Knowledge Base/_images/x86-registers.png|715]]

![[Cybersecurity Knowledge Base/_images/asciifull.gif]]

## Registers (64-bit) 

Modern (i.e., 386 and beyond) x86 processors have eight 32-bit general purpose registers, as depicted in the figure above. The register names are mostly historical. For example, EAX used to be called the accumulator since it was used by a number of arithmetic operations, and ECX was known as the counter since it was used to hold a loop index. Whereas most of the registers have lost their special purposes in the modern instruction set, by convention, two are reserved for special purposes — the stack pointer (ESP) and the base pointer (EBP).

For the EAX, EBX, ECX, and EDX registers, subsections may be used. For example, the least significant 2 bytes of EAX can be treated as a 16-bit register called AX. The least significant byte of AX can be used as a single 8-bit register called AL, while the most significant byte of AX can be used as a single 8-bit register called AH. These names refer to the same physical register. When a two-byte quantity is placed into DX, the update affects the value of DH, DL, and EDX. These sub-registers are mainly hold-overs from older, 16-bit versions of the instruction set. However, they are sometimes convenient when dealing with data that are smaller than 32-bits (e.g. 1-byte ASCII characters).

When referring to registers in assembly language, the names are not case-sensitive. For example, the names EAX and eax refer to the same register.

| **Register**            | **Name**            |
| ----------------------- | ------------------- |
| *%rip*                    | Instruction pointer |
| *%rsp*                    | Stack pointer       |
| *%rax*                    | Return value        |
| *%rdi*                    | 1st argument        |
| *%rsi*                    | 2nd argument        |
| *%rdx*                    | 3rd argument        |
| *%rcx*                    | 4th argument        |
| *%r8*                     | 5th argument        |
| *%r9*                     | 6th argument        |
| *%r10, %r11*              | Callee-owned        |
| *%rbx, %rbp, %r12 - %r15* | Caller-owned        |

#### Register Names (64-bit) 

| **64-bit register (8-byte)** | **32-bit register (Bytes 0-3)** | **16-bit register (Bytes 0-1)** | **8-bit register (Byte 0)** |
| ---------------------------- | ------------------------------- | ------------------------------- | --------------------------- |
| %rax                         | %eax                            | %ax                             | %al                         |
| %rbx                         | %ebx                            | %bx                             | %bl                         |
| %rcx                         | %ecx                            | %cx                             | %cl                         |
| %rdx                         | %edx                            | %dx                             | %dl                         |
| %rsi                         | %esi                            | %si                             | %sil                        |
| %rdi                         | %edi                            | %di                             | %dil                        |
| %rbp                         | %ebp                            | %bp                             | %bpl                        |
| %rsp                         | %esp                            | %sp                             | %spl                        |
| %r8                          | %r8d                            | %r8w                            | %r8b                        |
| %r9                          | %r9d                            | %r9w                            | %r9b                        |
| %r10                         | %r10d                           | %r10w                           | %r10b                       |
| %r11                         | %r11d                           | %r11w                           | %r11b                       |
| %r12                         | %r12d                           | %r12w                           | %r12b                       |
| %r13                         | %r13d                           | %r13w                           | %r13b                       |
| %r14                         | %r14d                           | %r14w                           | %r14b                       |
| %r15                         | %r15d                           | %r15w                           | %r15b                       |

### Data Registers (32-bit)

There are four main registers for storing data:

- **`eax`**: Accumulator.
- **`ebx`**: Base.
- **`ecx`**: Counter.
- **`edx`**: Data.

These registers are 32 bits in length but can be broken down into smaller components:

- **16-bit size**:
    - `AX`, `BX`, `CX`, `DX`, etc.
- **8-bit size**:
    - Higher bit: `AH`, `BH`, `CH`, `DH`, etc.
    - Lower bit: `AL`, `BL`, `CL`, `DL`, etc.

### Pointer Registers (32-bit)

- **`eip`**: Instruction Pointer
    - Keeps track of the address of the next instruction in memory, so the CPU knows what instruction to execute next.
- **`esp`**: Stack Pointer
    - Points to the top of the stack, allowing us to keep track of the top of the stack.
- **`ebp`**: Base Pointer
    - Points to the base of the function, serving as a reference point to keep track of the parameters and local variables of a function.
    - Used when a function is called and resets when we leave the function.

### Index Registers (32-bit)

- **`esi`**: Source index.
- **`edi`**: Destination index.

These registers are commonly used in memory copy operations:

- The source data is stored in the source index (`esi`).
- The destination index (`edi`) contains a pointer to the desired address.
- The data is then copied to the address specified by `edi`.

#### Segment Registers

Segments are specific areas defined in a program for containing data, code, and the stack. There are three main segments:

- **Code Segment (CS)**: Contains all the instructions to be executed. A 16-bit Code Segment register (CS) stores the starting address of the code segment.
- **Data Segment (DS)**: Contains data, constants, and work areas. A 16-bit Data Segment register (DS) stores the starting address of the data segment.
- **Stack Segment (SS)**: Contains data and return addresses of procedures or subroutines, implemented as a 'stack' data structure. The Stack Segment register (SS) stores the starting address of the stack.

Apart from the DS, CS, and SS registers, there are additional segment registers:

- **Extra Segment (ES)**
- **FS**
- **GS**

These provide additional segments for storing data. 

In assembly programming, a program needs to access the memory locations. All memory locations within a segment are relative to the starting address of the segment. A segment begins in an address evenly divisible by 16 or hexadecimal 10. So, the rightmost hex digit in all such memory addresses is 0, which is not generally stored in the segment registers.

The segment registers stores the starting addresses of a segment. To get the exact location of data or instruction within a segment, an offset value (or displacement) is required. To reference any memory location in a segment, the processor combines the segment address in the segment register with the offset value of the location.

## Instructions

Machine instructions generally fall into three categories: data movement, arithmetic/logic, and control-flow. In this section, we will look at important examples of x86 instructions from each category. This section should not be considered an exhaustive list of x86 instructions, but rather a useful subset. For a complete list, see Intel's instruction set reference.

We use the following notation:
```asm
<reg32>     Any 32-bit register (EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP)
<reg16>     Any 16-bit register (AX, BX, CX, or DX)
<reg8>       Any 8-bit register (AH, BH, CH, DH, AL, BL, CL, or DL)
<reg>         Any register
<mem>     A memory address (e.g., [eax], [var + 4], or dword ptr [eax+ebx])
<con32>   Any 32-bit constant
<con16>   Any 16-bit constant
<con8>     Any 8-bit constant
<con>       Any 8-, 16-, or 32-bit constant
```

### Data Movement Instructions

#### **mov** - Move 

- Opcodes: (88, 89, 8A, 8B, 8C, 8E, ...)
- The `mov` instruction copies the data item from its second operand (register contents, memory contents, or a constant value) into the location specified by its first operand (a register or memory). Direct memory-to-memory moves are not possible; memory transfers require loading the source memory contents into a register first, then storing them to the destination memory address.

##### Syntax
```asm
mov <reg>,<reg>
mov <reg>,<mem>
mov <mem>,<reg>
mov <reg>,<const>
mov <mem>,<const>
```

##### Examples
```asm
mov eax, 1          ; moves value 1 into the eax register
mov eax, ebx        ; moves contents of register ebx into eax
mov eax, [ebx]      ; moves value at memory address ebx into eax
mov [0x123456], ebx ; moves values in ebx to memory location 0x123456
mov [eax], ebx      ; moves values in ebx to memory location eax
mov dword ptr [0x654321], 1200h ; moves dword value 1200h into  memory address 0x654321

mov byte ptr [var], 5 ; store the value of 5 into the byte at location var
```

#### **push** - Push Stack 

- Opcodes: (FF, 89, 8A, 8B, 8C, 8E, ...)
- The `push` instruction places its operand onto the top of the hardware-supported stack in memory. Specifically, `push` first decrements ESP by 4, then places its operand into the 32-bit location at address [ESP]. ESP (the stack pointer) is decremented by `push` since the x86 stack grows down, from high addresses to lower addresses.

##### Syntax
```asm
push <reg32>
push <mem>
push <con32>
```

##### Examples
```asm
push eax     ; push eax on the stack  
push [var]   ; push the 4 bytes at address _var_ onto the stack
```

#### **pop** - Pop Stack

- The `pop` instruction removes the 4-byte data element from the top of the hardware-supported stack into the specified operand (register or memory location). It first moves the 4 bytes located at memory location `[ESP]` into the specified register or memory location, and then increments ESP by 4.

##### Syntax
```asm
pop <reg32>
pop <mem>
```

##### Examples
```asm
pop edi        ; pop the top element of the stack into EDI.  
pop [ebx]    ; pop the top element of the stack into memory at the four bytes starting at location EBX.
```

#### **lea** - Load Effective Address

- The `lea` instruction places the address specified by its second operand into the register specified by its first operand. Note that the contents of the memory location are not loaded, only the effective address is computed and placed into the register. This is useful for obtaining a pointer into a memory region.

##### Syntax
```asm
lea <reg32>, <mem>
```

##### Examples
```asm
lea edi, [ebx + 4 * esi]     ; the quantity EBX + 4 * ESI is placed in EDI.  
lea eax, [var]                ; the value in _var_ is placed in EAX.  
lea eax, [val]                ; the value _val_ is placed in EAX.
```

### Arithmetic and Logic Instructions

#### **add** - Integer Addition

- The `add` instruction adds its two operands together, storing the result in its first operand. Both operands may be registers, but at most one operand may be a memory location

##### Syntax
```asm
add <reg>,<reg>  
add <reg>,<mem>  
add <mem>,<reg>  
add <reg>,<con>  
add <mem>,<con>
```

##### Examples
```asm
add eax, 10     ; EAX ← EAX + 10  
add BYTE PTR [var], 10     ; add 10 to the single byte stored at memory address var
```

#### **sub** - Integer Subtraction

- The `sub` instruction stores in its first operand the result of subtracting the value of its second operand from the value of its first operand, similar to `add`.

##### Syntax
```asm
sub <reg>,<reg>  
sub <reg>,<mem>  
sub <mem>,<reg>  
sub <reg>,<con>  
sub <mem>,<con>
```

##### Examples
```asm
sub al, ah   ; AL ← AL - AH  
sub eax, 216   ; subtract 216 from the value stored in EAX
```

#### **inc, dec** - Increment, Decrement

- The `inc` instruction increments the contents of its operand by one. The `dec` instruction decrements the contents of its operand by one.

##### Syntax
```asm
inc <reg>  
inc <mem>  
dec <reg>  
dec <mem>
```

##### Examples
```asm
dec eax     ; subtract one from the contents of EAX.  
inc DWORD PTR [var]     ; add one to the 32-bit integer stored at location _var_
```

#### **imul** - Integer Multiplication

- The `imul` instruction has two basic formats: two-operand and three-operand.
	- The two-operand form multiplies its two operands together and stores the result in the first operand, which must be a register.
    - The three-operand form multiplies its second and third operands together and stores the result in its first operand, which must be a register. The third operand is restricted to being a constant value.

##### Syntax
```asm
imul <reg32>,<reg32>  
imul <reg32>,<mem>  
imul <reg32>,<reg32>,<con>  
imul <reg32>,<mem>,<con>
```

##### Examples
```asm
imul eax, [var]    ; multiply the contents of EAX by the 32-bit contents of the memory location _var_. Store the result in EAX.
imul esi, edi, 25   ; ESI → EDI * 25
```

#### **idiv** - Integer Division

- The `idiv` instruction divides the contents of the 64-bit integer EDX:EAX (with EDX as the most significant four bytes and EAX as the least significant four bytes) by the specified operand value. The quotient is stored in EAX, and the remainder is placed in EDX.

##### Syntax
```asm
idiv <reg32>  
idiv <mem>
```

##### Examples
```asm
idiv ebx   ; divide the contents of EDX:EAX by the contents of EBX. Place the quotient in EAX and the remainder in EDX.
idiv DWORD PTR [var]    ; divide the contents of EDX:EAX by the 32-bit value stored at memory location _var_. Place the quotient in EAX and the remainder in EDX.
```

#### **and, or, xor** - Bitwise Logical And, Or, and Exclusive Or.

- These instructions perform the specified logical operation (bitwise and, or, and exclusive or) on their operands, placing the result in the first operand location.

##### Syntax
```asm
and <reg>,<reg>  
and <reg>,<mem>  
and <mem>,<reg>  
and <reg>,<con>  
and <mem>,<con>

or <reg>,<reg>  
or <reg>,<mem>  
or <mem>,<reg>  
or <reg>,<con>  
or <mem>,<con>

xor <reg>,<reg>  
xor <reg>,<mem>  
xor <mem>,<reg>  
xor <reg>,<con>  
xor <mem>,<con>
```

##### Examples
```asm
and eax, 0fH   ; clear all but the last 4 bits of EAX.  
xor edx, edx   ; set the contents of EDX to zero.
```

#### **not** - Bitwise Logical Not

- Logically negates the operand contents (flips all bit values in the operand).

##### Syntax
```asm
not <reg>  
not <mem>
```

##### Example
```asm
not BYTE PTR [var]   ; negate all bits in the byte at the memory location _var_.
```

#### **neg** - Negate

- Performs the two's complement negation of the operand contents.

##### Syntax
```asm
neg <reg>  
neg <mem>
```

##### Example
```asm
neg eax    ; EAX → - EAX
```

#### **shl, shr** - Shift Left, Shift Right

- These instructions shift the bits in their first operand's contents left and right, padding the resulting empty bit positions with zeros. The shifted operand can be shifted up to 31 places. The number of bits to shift is specified by the second operand, which can be either an 8-bit constant or the register CL. In either case, shifts counts of greater than 31 are performed modulo 32.

##### Syntax
```asm
shl <reg>,<con8>  
shl <mem>,<con8>  
shl <reg>,<cl>  
shl <mem>,<cl>

shr <reg>,<con8>  
shr <mem>,<con8>  
shr <reg>,<cl>  
shr <mem>,<cl>
```

##### Examples
```asm
shl eax, 1   ; Multiply the value of EAX by 2 (if the most significant bit is 0)
shr ebx, cl  ;  Store in EBX the floor of result of dividing the value of EBX by 2_n_ where_n_ is the value in CL.
```

### Control Flow Instructions

The x86 processor maintains an instruction pointer (IP) register that is a 32-bit value indicating the location in memory where the current instruction starts. Normally, it increments to point to the next instruction in memory begins after execution an instruction. The IP register cannot be manipulated directly, but is updated implicitly by provided control flow instructions.

We use the notation `<label>` to refer to labeled locations in the program text. Labels can be inserted anywhere in x86 assembly code text by entering a label name followed by a colon. For example,

```asm
mov esi, [ebp + 8]

begin: xor ecx, ecx
       mov eax, [esi]
```

The second instruction in this code fragment is labeled begin. Elsewhere in the code, we can refer to the memory location that this instruction is located at in memory using the more convenient symbolic name begin. This label is just a convenient way of expressing the location instead of its 32-bit value.

#### **jmp** - Jump

- Transfers program control flow to the instruction at the memory location indicated by the operand.

##### Syntax
```asm
jmp <label>
```

##### Example
```asm
jmp begin   ; Jump to the instruction labeled begin.
```


**j*condition*** - Conditional Jump

- These instructions perform conditional jumps based on the status of condition codes stored in a special register called the *machine status word*. This register includes information about the last arithmetic operation performed, such as whether the result was zero or negative. Based on these condition codes, various conditional jumps can be performed. For example, the `jz` instruction jumps to the specified label if the last result was zero; otherwise, control proceeds to the next instruction.
- Conditional branches are often used in conjunction with the `cmp` instruction to compare operands.

##### Syntax
```asm
je <label>   ; jump when equal
jne <label>  ; jump when not equal
jz <label>   ; jump when last result was zero
jg <label>   ; jump when greater than
jge <label>  ; jump when greater than or equal to
jl <label>   ; jump when less than
jle <label>  ; jump when less than or equal to
```

##### Example
```asm
cmp eax, ebx  
jle done ; If the contents of EAX are less than or equal to the contents of EBX, jump to the label _done_. Otherwise, continue to the next instruction.
```

#### **cmp** - Compare

- Compares the values of the two specified operands, setting the condition codes in the machine status word appropriately. This instruction is equivalent to the `sub` instruction, except the result of the subtraction is discarded instead of replacing the first operand.

##### Syntax
```asm
cmp <reg>,<reg>  
cmp <reg>,<mem>  
cmp <mem>,<reg>  
cmp <reg>,<con>
```

##### Example
```asm
cmp DWORD PTR [var], 10  
jeq loop    ; If the 4 bytes stored at location _var_ are equal to the 4-byte integer constant 10, jump to the location labeled _loop_.
```

#### **call, ret** - Subroutine Call and Return

- The `call` instruction pushes the current code location onto the stack and then performs an unconditional jump to the code location indicated by the label operand. This saves the location to return to when the subroutine completes.
- The `ret` instruction pops a code location off the stack and performs an unconditional jump to that location, returning control to the point where the subroutine was called.

##### Syntax
```asm
call <label>  
ret
```

##### Examples
```asm
__funclabel:
		cmp DWORD PTR [var], 10

call __funclabel
retn
```

### Common Instructions

| **Instruction** | **S-Reg, D-Reg** |                                             **Operation**                                             |
| :-------------: | :--------------: | :---------------------------------------------------------------------------------------------------: |
|       mov       |     src, dst     |                                              `dst = src`                                              |
|     movsbl      |     src, dst     |                                       byte to int, sign-extend                                        |
|     movzbl      |     src, dst     |                                        byte to int, zero-fill                                         |
|      cmov       |     src, reg     |                `reg = src` when condition holds, using same condition suffixes as jmp                 |
|       lea       |    addr, dst     |                                             `dst = addr`                                              |
|       add       |     src, dst     |                                             `dst += src`                                              |
|       sub       |     src, dst     |                                             `dst -= src`                                              |
|      imul       |     src, dst     |                                             `dst *= src`                                              |
|       neg       |       dst        |                                   `dst = -dst` (arithmetic inverse)                                   |
|      imulq      |        S         |                        signed full multiply `R[%rdx]:R[%rax]  <-- S * R[%rax]`                        |
|      mulq       |        S         |                           unsigned full multiply; same effect as **imulq**                            |
|      idivq      |        S         |      signed divide `R[%rdx] <-- R[%rdx]:R[%rax] mod S          R[%rax] <-- R[%rdx]:R[%rax] / S`       |
|      divq       |        S         |                              unsigned divide - same effect as **idivq**                               |
|      cqto       |                  |                              `R[%rdx]:R[%rax] <-- SignExtend(R[R[%rax])`                              |
|       sal       |    count, dst    |                                            `dst <<= count`                                            |
|       sar       |    count, dst    |                                  `dst >>= count` (arithmetic shift)                                   |
|       shr       |    count, dst    |                                    `dst >>= count` (logical shift)                                    |
|       and       |     src, dst     |                                             `dst &= src`                                              |
|       or        |     src, dst     |                                      `dst \|= src` (bitwise or)                                       |
|       xor       |     src, dst     |                                             `dst ^= src`                                              |
|       not       |       dst        |                                    `dst = ~dst` (bitwise inverse)                                     |
|       cmp       |       a, b       |                                          `b - a`, set flags                                           |
|      test       |       a, b       |                                          `a & b`, set flags                                           |
|       set       |       dst        | sets byte at `dst` to `1` when condition holds, `0` otherwise, using same condition suffixes as `jmp` |
|       jmp       |      label       |                                    jump to label (unconditionally)                                    |
|       je        |      label       |                                          jump equal `ZF = 1`                                          |
|       jne       |      label       |                                        jump not equal `ZF = 0`                                        |
|       js        |      label       |                                        jump negative `SF = 1`                                         |
|       jns       |      label       |                                      jump not negative `SF = 0`                                       |
|       jg        |      label       |                                jump > (signed) `ZF = 0` and `SF = OF`                                 |
|       jge       |      label       |                                      jump >= (signed) `SF = OF`                                       |
|       jl        |      label       |                                      jump < (signed) `SF != OF`                                       |
|       jle       |      label       |                                jump <= (signed) `ZF = 1` or `SF != OF`                                |
|       ja        |      label       |                                jump > (unsigned) `CF = 0` and `ZF = 0`                                |
|       jae       |      label       |                                      jump >= (unsigned) `CF = 0`                                      |
|       jb        |      label       |                                      jump < (unsigned) `CF = 1`                                       |
|       jbe       |      label       |                                jump <= (unsigned) `CF = 1` or `ZF = 1`                                |
|      push       |       src        |                               add to top of stack; `Mem[--%rsp] = src`                                |
|       pop       |       dst        |                              remove top from stack; `dst = Mem[%rsp++]`                               |
|      call       |        fn        |                                       push `%rip`, jmp to `fn`                                        |
|       ret       |        -         |                                              `pop %rip`                                               |
|      repx       |    count, dst    |       `do { dst; } while (--count != 0);` (repeat while not zero, execute `dst` `count` times)        |
|      stosx      |    count, dst    |            `do { *dst = x; dst += size; } while (--count != 0);` (store `x` `count` times)            |
|      lodsx      |    count, dst    |                     Moves memory address contained in `esi` to the `al` register                      |
|      scasx      |                  |                 Used to search for the presence of a byte within a sequence of bytes                  |
|      cmpsX      |                  |          Checks ESI and EDI to see if they contain identical identical data (`strcmp` in C)           |

### Instruction Suffixes / Data Types 

| **Suffix** | **Size**                           |
| ---------- | ---------------------------------- |
| *b*          | byte (8 bits)                      |
| *w*          | word (16-bites, 2 bytes)           |
| *l*          | long/doubleword (32-bits, 4 bytes) |
| *q*          | quadword (64-bits, 8 bytes)        |
- **integer (int):** 4 bytes
- **character (char):** 1 byte

The suffix is elided when it can be inferred from operands. For example, the operand `%rax` implies `q`, `%eax` implies `l`, and so on. Most instructions, like `mov`, use a suffix to indicate the size of the operands. 

For example, moving a quadword from `%rax` to `%rbx` results in the instruction `movq %rax, %rbx`. Some instructions, like `ret`, do not use suffixes because there is no need. 

Others, such as `movs` and `movz`, use two suffixes to convert operands from the type of the first suffix to that of the second. For example, converting the byte in `%al` to a doubleword in `%ebx` with zero-extension would be `movzbl %al, %ebx`.

##  Condition codes/flags 

| **Condition Codes** | **Flag**      |
| ------------------- | ------------- |
| *ZF*              | Zero flag     |
| *SF*              | Sign flag     |
| *CF*              | Carry flag    |
| *OF*              | Overflow flag |

## Memory and Addressing Modes
### Declaring Static Data Regions

You can declare static data regions (analogous to global variables) in x86 assembly using special assembler directives. Data declarations should be preceded by the `.DATA` directive. Following this directive, the directives `DB`, `DW`, and `DD` can be used to declare one, two, and four byte data locations, respectively.

Declared locations can be labeled with names for later reference, similar to declaring variables by name but following lower-level rules. For example, locations declared in sequence will be located in memory next to one another.

**Example Declarations**:
```asm
.DATA          
var      DB 64      ; Declare a byte, referred to as location var, containing the value 64.
var2    DB ?       ; Declare an uninitialized byte, referred to as location var2.
          DB 10    ; Declare a byte with no label, containing the value 10. Its location is var2 + 1.
X        DW ?      ; Declare a 2-byte uninitialized value, referred to as location X.
Y        DD 30000   ; Declare a 4-byte value, referred to as location Y, initialized to 30000.
```

Unlike in high-level languages where arrays can have many dimensions and are accessed by indices, arrays in x86 assembly language are simply a number of cells located contiguously in memory. An array can be declared by just listing the values, as in the first example below.

Two other common methods for declaring arrays of data are the `DUP` directive and the use of string literals. The `DUP` directive tells the assembler to duplicate an expression a given number of times. For example, `4 DUP(2)` is equivalent to `2, 2, 2, 2`.

**Example Declarations**:
```asm
Z       DD 1, 2, 3  ; Declare three 4-byte values, initialized to 1, 2, and 3. The value of location Z + 8 will be 3.
bytes   DB 10 DUP(?)    ; Declare 10 uninitialized bytes starting at location bytes.
arr     DD 100 DUP(0)       ; Declare 100 4-byte words starting at location arr, all initialized to 0
str     DB 'hello',0    ; Declare 6 bytes starting at the address str, initialized to the ASCII character values for hello and the null (0) byte.
```

### Addressing Memory

Modern x86-compatible processors are capable of addressing up to 2^32 bytes of memory, meaning memory addresses are 32-bits wide. In the examples above, where labels are used to refer to memory regions, these labels are replaced by the assembler with 32-bit quantities that specify addresses in memory.

In addition to referring to memory regions by labels (i.e., constant values), x86 provides a flexible scheme for computing and referring to memory addresses: up to two of the 32-bit registers and a 32-bit signed constant can be added together to compute a memory address. One of the registers can be optionally pre-multiplied by 2, 4, or 8.

The addressing modes can be used with many x86 instructions. Here we illustrate some examples using the `mov` instruction, which moves data between registers and memory. This instruction has two operands: the first is the destination, and the second specifies the source.

**Examples of `mov` instructions using address computations**:
```asm
mov eax, [ebx]  ; Move the 4 bytes in memory at the address contained in EBX into EAX
mov [var], ebx  ; Move the contents of EBX into the 4 bytes at memory address var. (Note, var is a 32-bit constant).
mov eax, [esi - 4]    ; Move 4 bytes at memory address ESI + (-4) into EAX
mov [esi + eax], cl   ; Move the contents of CL into the byte at address ESI + EAX
mov edx, [esi + 4 * ebx]        ; Move the 4 bytes of data at address ESI + 4 * EBX into EDX
```

**Examples of invalid address calculations**:
```asm
mov eax, [ebx - ecx]  ; Can only add register values
mov [eax + esi + edi], ebx      ; At most 2 registers in address computation
```

### Size Directives

In general, the intended size of the data item at a given memory address can be inferred from the assembly code instruction in which it is referenced. For example, in the instructions above, the size of the memory regions could be inferred from the size of the register operand.

When loading a 32-bit register, the assembler infers that the memory region referred to is 4 bytes wide. When storing the value of a one-byte register to memory, the assembler infers that the address refers to a single byte in memory.

However, in some cases, the size of a referred-to memory region is ambiguous. Consider the instruction `mov [ebx], 2`. Should this instruction move the value 2 into the single byte at address EBX? Or should it move the 32-bit integer representation of 2 into the 4 bytes starting at address EBX? 

Since either interpretation is valid, the assembler must be explicitly directed as to which is correct. The size directives `BYTE PTR`, `WORD PTR`, and `DWORD PTR` serve this purpose, indicating sizes of 1, 2, and 4 bytes respectively.

**Examples**:
```asm
mov BYTE PTR [ebx], 2   ; Move 2 into the single byte at the address stored in EBX.
mov WORD PTR [ebx], 2   ; Move the 16-bit integer representation of 2 into the 2 bytes starting at the address in EBX.
mov DWORD PTR [ebx], 2      ; Move the 32-bit integer representation of 2 into the 4 bytes starting at the address in EBX.
```

### Addressing Modes
#### Immediate
- Source is a constant value.

```asm
mov $0x5, dst
```

#### Register
- `%R` is a register.
- Source is in the `%R` register.

```asm
mov %rax, dst
```

#### Direct
- Source is read from `Mem[0xaddr]`.

```asm
mov 0x4033d0, dst
```

#### Indirect
- `%R` is a register.
- Source is read from `Mem[%R]`.

```asm
mov (%rax), dst
```

##### Indirect Displacement
- `%R` is a register.
- `D` is displacement.
- Source is read from `Mem[%R + D]`.

```asm
mov 8(%rax), dst
```

##### Indirect Scaled-Index
- `%RB` is the register for the base.
- `%RI` is the register for the index (0 if empty).
- `D` is displacement (0 if empty).
- `S` is scale 1, 2, 4, or 8 (1 if empty).
- Source is read from `Mem[%RB + D + S * %RI]`.

```asm
mov 8(%rsp, %rcx, r), dst
```

## Operands

Instructions operate on the following:
- **Registers**:
    - `EIP` is not allowed; others may be limited.
    - Some registers are implicit (e.g., `EFLAGS` may change but is not listed).
        - Example: `add eax, ebx` (eax + ebx → eax).
- **Immediate (source operands only)**:
    - These are literal, constant values (may refer to addresses).
        - Examples:
```asm
mov eax, 4
mov byte ptr [0x800404], 5  ; move 5 into the byte location 0x0800404
jmp 0x400cc1                ; jump to location 0x400cc1
```
- **Memory references**:
	- Operands can contain pointers to memory locations.
		- Example:
```asm
mov [eax], 5
```

### Operand Specifiers

The basic types of operand specifiers are listed below. In the following table:
* **imm** refers to a constant value, e.g. `0x8048d8e` or `48`
* **E$_x$** refers to a register, e.g. `%rax` 
* **R(E$_x$)** refers to the value stored in register **E$_x$** 
* **M(x)** refers to the value stored at memory address **x**

| Type      | From                   | Operand Value                        | Name      |
| --------- | ---------------------- | ------------------------------------ | --------- |
| Immediate | *$Imm*                 | *Imm*                                | Immediate |
| Register  | *E$_a$*                | *R(E$_a$)*                           | Register  |
| Memory    | *Imm*                  | *M(Imm)*                             | Absolute  |
| Memory    | *(E$_a$)*              | *M(R(E$_b$))*                        | Absolute  |
| Memory    | *Imm(E$_b$, E$_i$, s)* | *M(Imm + R(E$_b$) + (R(E$_i$) x s))* | Scaled index          |

## Data Types

### Arrays

- An array is a list containing elements of the same data type.
- The address of each element in an array is computed using:
    - Base address of the array
    - Index of the element
    - Size of each element

```asm
leet[n] = base address of leet + index+size of element

leet[0] = [leet + 0*4] = [0x1337+0*4] = [0x1337]
leeet[1] = [leet + 1*4] = [0x1337 + 1*4] = [0x1341]
leet[2] = [leet + 2*4] = [0x1337 + 2*4] = [0x1345]
leet[3] = [leet + 3*4] = [0x1337 + 3*4] = [0x1349]
```

### Strings

- Strings are pointer variables that point to the first character in a string.
- The string continues until a null byte is encountered.

## Assembler Directives

x86 assembly has three primary sections:

- **data**: Used to create variables when the value is known ahead of time.
- **bss**: Used to declare variables that are not initialized by the program.
- **text**: Contains the actual code or instructions to be executed.

For more information, refer to the [Oracle documentation](vscode-file://vscode-app/c:/Users/nsickels/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html).


## Calling Convention

To allow separate programmers to share code and develop libraries for use by many programs, and to simplify the use of subroutines in general, programmers typically adopt a common *calling convention*. 

The calling convention is a protocol about how to call and return from routines. For example, given a set of calling convention rules, a programmer need not examine the definition of a subroutine to determine how parameters should be passed to that subroutine. 

Furthermore, given a set of calling convention rules, high-level language compilers can be made to follow the rules, thus allowing hand-coded assembly language routines and high-level language routines to call one another.

In practice, many calling conventions are possible. We will use the widely used C language calling convention. Following this convention will allow you to write assembly language subroutines that are safely callable from C (and C++) code, and will also enable you to call C library functions from your assembly language code.

The C calling convention is based heavily on the use of the hardware-supported stack. It is based on the `push`, `pop`, `call`, and `ret` instructions. Subroutine parameters are passed on the stack. Registers are saved on the stack, and local variables used by subroutines are placed in memory on the stack. The vast majority of high-level procedural languages implemented on most processors have used similar calling conventions.

The calling convention is broken into two sets of rules. The first set of rules is employed by the caller of the subroutine, and the second set of rules is observed by the writer of the subroutine (the callee).

It should be emphasized that mistakes in the observance of these rules quickly result in fatal program errors since the stack will be left in an inconsistent state; thus meticulous care should be used when implementing the call convention in your own subroutines.

![[calling-conventions-x86.png]]

A good way to visualize the operation of the calling convention is to draw the contents of the nearby region of the stack during subroutine execution. The image above depicts the contents of the stack during the execution of a subroutine with three parameters and three local variables. 

The cells depicted in the stack are 32-bit wide memory locations, thus the memory addresses of the cells are 4 bytes apart. The first parameter resides at an offset of 8 bytes from the base pointer.

Above the parameters on the stack (and below the base pointer), the call instruction placed the return address, thus leading to an extra 4 bytes of offset from the base pointer to the first parameter. When the ret instruction is used to return from the subroutine, it will jump to the return address stored on the stack.

### Caller Rules

To make a subroutine call, the caller should:

1. **Save Caller-Saved Registers**:
    - Before calling a subroutine, save the contents of certain registers that are designated as caller-saved. The caller-saved registers are EAX, ECX, and EDX. 
    - Since the called subroutine is allowed to modify these registers, if the caller relies on their values after the subroutine returns, the caller must push the values in these registers onto the stack so they can be restored after the subroutine returns.
1. **Pass Parameters**:
    - Push the parameters onto the stack before the call. The parameters should be pushed in inverted order (i.e., last parameter first). Since the stack grows down, the first parameter will be stored at the lowest address. 
    - This inversion of parameters was historically used to allow functions to be passed a variable number of parameters.
2. **Call the Subroutine**:
    - Use the `call` instruction to call the subroutine. This instruction places the return address on top of the parameters on the stack and branches to the subroutine code. 
    - This invokes the subroutine, which should follow the callee rules.

After the subroutine returns (immediately following the `call` instruction), the caller can expect to find the return value of the subroutine in the register EAX. To restore the machine state, the caller should:

1. **Remove Parameters from Stack**:
    - Remove the parameters from the stack. This restores the stack to its state before the call was performed.
2. **Restore Caller-Saved Registers**:
    - Restore the contents of caller-saved registers (EAX, ECX, EDX) by popping them off the stack. The caller can assume that no other registers were modified by the subroutine.

#### Example

The code below shows a function call that follows the caller rules. The caller is calling a function `_myFunc` that takes three integer parameters. First parameter is in EAX, the second parameter is the constant 216; the third parameter is in memory location `var`.
```asm
push [var] ; Push last parameter first
push 216   ; Push the second parameter
push eax   ; Push first parameter last

call _myFunc ; Call the function (assume C naming)

add esp, 12
```

Note that after the call returns, the caller cleans up the stack using the `add` instruction. We have 12 bytes (3 parameters * 4 bytes each) on the stack, and the stack grows down. Thus, to get rid of the parameters, we can simply add 12 to the stack pointer.

The result produced by `_myFunc` is now available for use in the register EAX. The values of the caller-saved registers (ECX and EDX) may have been changed. If the caller uses them after the call, it would have needed to save them on the stack before the call and restore them after it.

### Callee Rules

The definition of the subroutine should adhere to the following rules at the beginning of the subroutine:

1. **Set Up the Base Pointer**:
    - Push the value of EBP onto the stack, and then copy the value of ESP into EBP using the following instructions  as shown below.
    - This maintains the *base pointer (EBP)*, which is used as a reference point for finding parameters and local variables on the stack. The base pointer holds a copy of the stack pointer value from when the subroutine started executing. 
    - Parameters and local variables will always be located at known, constant offsets from the base pointer value. Pushing the old base pointer value at the beginning of the subroutine allows restoring the appropriate base pointer value for the caller when the subroutine returns.
```asm
push ebp
mov ebp, esp
```

2. **Allocate Local Variables**:
	-  Allocate space on the stack for local variables by decrementing the stack pointer. The amount by which the stack pointer is decremented depends on the number and size of local variables needed. 
	- For example, if 3 local integers (4 bytes each) are required, the stack pointer would be decremented by 12 to make space for these local variables:
```asm
sub esp, 12
```
3. **Save Callee-Saved Registers**:
    - Save the values of the *callee-saved* registers that will be used by the function by pushing them onto the stack. The callee-saved registers are EBX, EDI, and ESI (ESP and EBP will also be preserved by the calling convention but need not be pushed on the stack during this step).

After these three actions are performed, the body of the subroutine may proceed. When the subroutine returns, it must follow these steps:

1. **Leave the Return Value in EAX**:
    - Ensure the return value is in the EAX register.
2. **Restore Callee-Saved Registers**:
    - Restore the old values of any callee-saved registers (EBX, EDI, and ESI) that were modified by popping them from the stack. The registers should be popped in the inverse order that they were pushed.
3. **Deallocate Local Variables**:
    - Deallocate local variables by moving the value in the base pointer into the stack pointer as shown below. 
    - This works because the base pointer always contains the value that the stack pointer contained immediately prior to the allocation of the local variables.
```asm
mov esp, ebp
```
4. **Restore the Caller’s Base Pointer**:
    - Restore the caller's base pointer value by popping EBP off the stack. Recall that the first thing done on entry to the subroutine was to push the base pointer to save its old value.
5. **Return to the Caller**:
    - Return to the caller by executing a `ret` instruction. This instruction will find and remove the appropriate return address from the stack.

Note that the callee's rules fall cleanly into two halves that are basically mirror images of one another. The first half of the rules apply to the beginning of the function and are commonly said to define the *prologue* of the function. The latter half of the rules apply to the end of the function and are thus commonly said to define the *epilogue* of the function.

#### Example

Here is an example function definition that follows the callee rules:

```asm
.486
.MODEL FLAT
.CODE
PUBLIC _myFunc
_myFunc PROC
  ; Subroutine Prologue
  push ebp     ; Save the old base pointer value.
  mov ebp, esp ; Set the new base pointer value.
  sub esp, 4   ; Make room for one 4-byte local variable.
  push edi     ; Save the values of registers that the function
  push esi     ; will modify. This function uses EDI and ESI.
  ; (no need to save EBX, EBP, or ESP)

  ; Subroutine Body
  mov eax, [ebp+8]   ; Move value of parameter 1 into EAX
  mov esi, [ebp+12]  ; Move value of parameter 2 into ESI
  mov edi, [ebp+16]  ; Move value of parameter 3 into EDI

  mov [ebp-4], edi   ; Move EDI into the local variable
  add [ebp-4], esi   ; Add ESI into the local variable
  add eax, [ebp-4]   ; Add the contents of the local variable
                     ; into EAX (final result)

  ; Subroutine Epilogue 
  pop esi      ; Recover register values
  pop edi
  mov esp, ebp ; Deallocate local variables
  pop ebp      ; Restore the caller's base pointer value
  ret
_myFunc ENDP
END
```

The subroutine prologue performs the standard actions of saving a snapshot of the stack pointer in EBP (the base pointer), allocating local variables by decrementing the stack pointer, and saving register values on the stack.

In the body of the subroutine, we can see the use of the base pointer. Both parameters and local variables are located at constant offsets from the base pointer for the duration of the subroutine's execution. 

In particular, we notice that since parameters were placed onto the stack before the subroutine was called, they are always located below the base pointer (i.e., at higher addresses) on the stack. The first parameter to the subroutine can always be found at memory location `EBP + 8`, the second at `EBP + 12`, and the third at `EBP + 16`.

Similarly, since local variables are allocated after the base pointer is set, they always reside above the base pointer (i.e., at lower addresses) on the stack. In particular, the first local variable is always located at `EBP - 4`, the second at `EBP - 8`, and so on. This conventional use of the base pointer allows us to quickly identify the use of local variables and parameters within a function body.

The function epilogue is basically a mirror image of the function prologue. The caller's register values are recovered from the stack, the local variables are deallocated by resetting the stack pointer, the caller's base pointer value is recovered, and the `ret` instruction is used to return to the appropriate code location in the caller.

## Impact 

- **Performance Optimization**: Enables the creation of highly optimized code for performance-critical applications.
- **System-Level Programming**: Essential for developing operating systems, drivers, and firmware.
- **Embedded Systems**: Widely used in programming microcontrollers and other embedded devices.
- **Educational Value**: Provides a deep understanding of computer architecture and low-level programming concepts.

## Defense Mechanisms

- **Code Reviews**: Ensuring the correctness and security of assembly code through thorough reviews.
- **Static Analysis Tools**: Analyzing assembly code for potential vulnerabilities and inefficiencies.
- **Testing and Validation**: Rigorous testing to ensure the assembly code behaves as expected.
- **Secure Coding Practices**: Following best practices to avoid common pitfalls and vulnerabilities.

## Exploitable Mechanisms/Weaknesses

If not properly managed, x86 Assembly Language can be prone to errors such as buffer overflows, memory leaks, and other vulnerabilities. The complexity and low-level nature of the language can make it difficult to maintain and debug, leading to potential security risks.

## Current Status

x86 Assembly Language remains a critical tool for system-level programming, performance optimization, and embedded systems development. While high-level languages dominate most application development, assembly language is still widely used in scenarios requiring fine-grained control and maximum performance. Advanced tools and techniques continue to evolve, aiding in the development, analysis, and optimization of assembly code.

## References

- [Tutorialspoint Assembly Programming Tutorial](https://www.tutorialspoint.com/assembly_programming/)
- [x86 Assembly Guide](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html)
- [x86 Instruction Listings](#https://en.wikipedia.org/wiki/X86_instruction_listings) 
- [Online x86 Assembler](https://defuse.ca/online-x86-assembler-assembler.htm)
- [Intel's Pentium Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [x86 and amd64 Assembly Instruction Reference](https://www.felixcloutier.com/x86/)

## Revision History

- **2024-09-10**: Entry created.
