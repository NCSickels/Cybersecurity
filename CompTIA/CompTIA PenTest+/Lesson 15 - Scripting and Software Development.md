## Lesson Introduction
---
In order to effectively conduct PenTesting, the team will need to analyze code and code samples. To achieve this goal, the team should be familiar with the various Linux shells, along with a variety of programming languages that include Python, Ruby, and JavaScript. In addition, the team should be familiar with various logic constructs such as loops, Boolean operators, dictionaries, lists, and trees. Finally, the team will most likely include the use of automated PenTesting that includes performing a port scan and then automating the next steps based on results.

## Lesson Objectives
---
In this lesson, you will:

- View code samples using system shells, such as Linux Bash, and Microsoft Windows PowerShell.
- View code samples using the Python programming language.
- View code examples using a variety of alternate programming languages, such as Ruby, Perl, and JavaScript.
- View various logic constructs such as loops and conditionals.
- Learn about scripting concepts, such as modules, libraries, and data structures.
- Learn about the possibility of automating penetration testing by enhancing your tools with scripts.

## Topic 15A - Analyzing Scripts and Code Samples
---
> [!note] Exam Objectives Covered
> *5.2 Given a scenario, analyze script or code sample for use in a penetration test.*

Automating the tasks that you perform in your penetration tests is a beneficial skill to have. It can save time and speed up your PenTest project. Now that you are familiar with several tools of PenTesting, it is a good time to analyze and run scripts that can help you customize the tools.
<font style="color: red">VIDEO NEEDED</font>

### Automating Tasks Using Scripting
---
Automation using scripting means that each configuration or build task is performed by a block of code. The script will take standard arguments as data so there is less scope for uncertainty over configuration choices leading to errors.

<mark style="background: #FFF3A3A6;">A well written script will use the following elements:</mark>

- <mark style="background: #FFF3A3A6;">Parameters that the script takes as input data (passed to the script as arguments).</mark>
- <mark style="background: #FFF3A3A6;">Branching and looping statements that can alter the flow of execution based on conditions.</mark>
- <mark style="background: #FFF3A3A6;">Validation and error handlers to check inputs and ensure robust execution.</mark>
- <mark style="background: #FFF3A3A6;">Unit tests to ensure that the script returns the expected outputs, given the expected inputs.</mark>

Popular scripting shells include Bash for Linux ( [tldp.org/LDP/abs/html](http://tldp.org/LDP/abs/html) ) and PowerShell for Windows ( [docs.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7](https://docs.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7) ). Scripts can also be written in programming languages such Python ([python.org](https://www.python.org/)), Ruby ([ruby-lang.org/en](https://www.ruby-lang.org/en/)), Perl ( [www.perl.org](http://www.perl.org/) ), and JavaScript ([w3schools.com/js](https://www.w3schools.com/js/)).

All coding languages have a specific syntax that constrains the way sections of code are laid out in blocks and the standard statements that are available, such as branching and looping constructs.

A **script** can be defined as any computer program that automates the execution of tasks for a particular runtime environment. Scripts are written in scripting languages, or interpreted programming languages. Scripts typically do not have the full feature set of a full-fledged **compiled code** program but instead integrate with other programs and operating system components to achieve automation.

For the purposes of a PenTest, scripting can greatly enhance the efficiency and effectiveness of the tasks that you conduct in many different phases. For example, the scope of the PenTest might state that in the target subnet there are _n_ number of hosts, and you want to be absolutely sure that this is accurate.

You could do a standard Nmap host scan and manually count the number of hosts, but this could get tedious, especially in larger subnets. With the power of scripting, you could set up Nmap to do its host scan, then output a warning if the number of identified hosts does not match _n_. You could also write the script to identify and output which hosts are not on an IP address **allow list** so you know what to avoid or what to investigate further.

Scripts are not just about enhancing existing tools' functionality, either. You can also create your own simple tools through scripts that are more customized to your needs. For example, you could create your own port scanner that is more attuned to your work style, or to the target environment, rather than relying on Nmap.

### Using the Bash Shell
---
When you enter Command Line mode on a Linux system, you have to use a **shell** so the operating system can understand your commands. Microsoft Windows has the command prompt, and Linux has the shell.

Bash is a scripting language and command shell for Unix-like systems. It is the default shell for Linux and older versions of macOS® and has its own command syntax. If you are familiar with Linux, most likely the commands you have been entering use the Bash shell to execute.

As a scripting language, Bash is useful for automating tasks in a Unix-like environment through the use of system calls and leveraging existing tools. Essentially any program, tool, utility, or system function that you can call at the command line you can also invoke in a Bash script. Likewise, Bash scripts support modern programming elements such as loops and conditional statements to enhance the logic of the task(s) being automated.

In the world of PenTesting, Bash scripting is useful for a wide variety of purposes, including:

- Automating the creation of files and directory structures.
- Quickly scanning and identifying actionable information in log and other text files.
- Manipulating the output of existing security tools like Nmap, tcpdump, Metasploit, etc.
- Extending the functionality of existing system utilities and security tools.

Because of its association with the underlying Unix-like operating system, the syntax of a Bash script is very similar to what you would input line-by-line at a terminal. The following is an example of a simple Bash script named **admin-hash-pull** that outputs a Windows Administrator's LM/NTLM hash from a dump file:

``` bash
#!/bin/bash
echo "Pulling Admin password hash from dump file..."
grep "Administrator" /root/dumps/winsrv_hash_dump.txt | cut -d ":" -f3-4 > admin-hash.txt
echo "Admin LM/NTLM hash extracted!"
```

The first line of the script indicates what type of interpreter the system should run, as there are several scripting languages beyond just Bash. The echo lines simply print messages to the console.

The grep command searches for any line in the hash dump text file that contains the text "Administrator." This command is then piped to the cut command which trims the output to only show the LM/NTLM hash values. These results are sent to a file called **admin-hash.txt**.

> [!warning] For a more in-depth look at Bash scripting, visit [www.tldp.org/LDP/abs/html](http://www.tldp.org/LDP/abs/html/).

> [!warning] Windows 10 includes a Linux subsystem that supports the Bash shell.

> [!important] Bash scripting cheat sheet is available at: https://devhints.io/bash

### Deploying PowerShell cmdlets
---
PowerShell is a scripting language and shell for Microsoft® Windows ® that is built on the .NET Framework. It is the default shell on Windows 10. PowerShell offers much greater functionality than the traditional Windows command prompt. Like Bash, the PowerShell scripting language supports a wide variety of programming elements.

PowerShell scripts provide much the same benefits as Bash, though tailored to work with Windows environments and system utilities. PowerShell can make it easier for PenTesters to automate the process of exploiting the Registry, Active Directory objects, Group Policy, the Windows network stack, and more.

PowerShell functions mainly through the use of cmdlets, which are specialized .NET commands that interface with PowerShell. A cmdlet is a compiled library that exposes some configuration or administrative task, for example starting a VM in Hyper-V.

These cmdlets typically take the syntax of Verb-Noun, such as Set-Date to change a system's date and time.

The following is an example of a simple PowerShell script named **clear-log.ps1**:

```powershell
Write-Host "Clearing event log..."

Clear-EventLog -logname Security, Application -computername Server01

Write-Host "Event log cleared!"
```

The Write-Host cmdlets print the given text to the PowerShell window. The `Clear-EventLog` cmdlet clears the Security and Application logs from the specified server (in this case Server01).

Cmdlets always return an object. Typically, the return from a cmdlet will be piped to some other cmdlet or function. For example:

`Get-Process | Where { $_.name -eq 'nmap' } | Format-List`

This will get the processes that are named “Nmap” and display their details in a list format.

PowerShell is the preferred method of performing Windows administration tasks. It has also become the Windows hacker's go-to toolkit. PowerShell statements can be executed at a PowerShell prompt or run as a script (.ps1) on any PowerShell-enabled host.

The Get-Help cmdlet shows help on different elements of the PowerShell environment. PowerShell is case-insensitive.

Varonis' blog series illustrates uses of PowerShell as a security administration platform ([_varonis.com/blog/practical-powershell-for-it-security-part-i-file-event-monitoring_](https://www.varonis.com/blog/practical-powershell-for-it-security-part-i-file-event-monitoring/)_)._

> [!important] The PowerShell execution policy **`RemoteSigned`** allows the execution of any PowerShell script that you write on the local machine but requires that scripts downloaded from the Internet be signed by a trusted publisher.

### Grasping Python's Syntax
---
Python ([python.org](https://www.python.org/)) is a popular language for implementing all kinds of development projects, including automation tools and security tools, as well as malicious scripts. Python is designed to be highly readable and use simple, clean syntax. Because of this, it is an excellent beginner programming language and a language used to teach programming paradigms such as object-oriented programming (OOP).

Unlike Bash and PowerShell, Python is not a command shell tied to an operating system architecture. Its interpreter is cross-platform and features its own programming libraries. Being an interpreted language means that a program is run within an executable environment and is not compiled into an executable itself. This executable environment must be activated when the script is run.

Python's syntax is designed around the use of whitespace. Blocks of code are initiated and terminated with indentation, rather than the curly braces you might see in similar programming languages like Java. Python is case-sensitive; for example, the variable user cannot be referred to by the label User or USER.

Comment lines are marked by the # character. You can view inline help on modules, functions, and keywords using the help statement. For example, the following command shows help for the print function:

`help(print)`

Python is also a popular scripting language in the world of penetration testing. Its robust standard library contributes to this, as many existing PenTesting utilities and frameworks are built using Python, including Volatility, Scapy, Recon-ng, and many more.

Python has libraries for network scanning, reverse engineering, application fuzzing, web exploitation, etc. Python version 2 is included in most Linux distributions, including Kali Linux, though Python 3 is the latest version and is not backward compatible.

> [!warning] Python recently upgraded to version 3, but there are many version 2 scripts still in use. Make sure you are loading the correct environment to run the scripts, version 2 and version 3 scripts do not always work well if you load them in the others environment.

Python might seem wordier than the equivalent script in Bash or PowerShell. This is because you don't necessarily write scripts to explicitly access system commands but instead write to Python's libraries that interact with the system.

The following is a snippet of a Python script named **os-identifier.py**:

```python
print "Detecting OS..."
if sys.platform == "linux":
print "Linux system detected!"
```


The print command, as the name implies, prints the given text to the screen. The if statement uses the sys.platform function to determine what operating system the Python interpreter is running on.

### Optimizing Workflow with Ruby
---
Ruby, like Python, is a general-purpose interpreted programming language that can also be used as a scripting language. It has many similarities to Python, including the fact that it is commonly used as a first programming language. Its most popular application is in the world of web application development, particularly through the Ruby on Rails framework.

Nevertheless, Ruby is also used in PenTest scripting, though less often than Python. Its standard library is smaller than Python's but more tightly curated. Perhaps the most compelling reason to learn and use Ruby is that the Metasploit Framework is written in Ruby.

Metasploit is one of the most important technical tools in a PenTester's arsenal and being able to extend its functionality through Ruby scripting can prove invaluable. One downside in comparing Ruby to Python is that Python is usually faster. However, this will not necessarily have any practical effect on the scripts you write.

Ruby's syntax is similar to Python's when it comes to clarity and simplicity, but Ruby doesn't require the use of whitespace to separate blocks of code—it looks for line breaks, keywords, and curly braces. In fact, Ruby is more flexible in its syntax and there are many ways to write the same program, whereas in Python, there is typically one "best" way to do something.

The following is a snippet of a Ruby script name **os-identifier.rb,** which is one possible equivalent of the previous Python snippet:

```ruby
puts "Detecting OS..."
if RUBY_PLATFORM == "x86_64-linux-gnu"
puts "Linux system detected!"
end
```

The puts command is equivalent to Python's print command. The if statement uses the RUBY_PLATFORM constant to determine what operating system the Ruby interpreter is running on.

### Scripting with Perl
---
Perl, like Python and Ruby before it, is also a general-purpose interpreted programming language that can also be used as a scripting language.

It was created in the late eighties as a general-purpose Unix scripting language for text manipulation. Today it supports a wide range of tasks including system administration and, of course, PenTesting.

Perl code for a given algorithm can be short and highly compressible.

The language is intended to be practical, easy to use, and efficient. One of its advantages is it has powerful built-in support for text processing and a huge collection of third-party modules.

The following is a snippet of a Perl script to show the version of OS.

`print "$^O\n";`

This script will display “linux” for Linux and MSWin32 for Windows (whether it is 32-bit or 64-bit).

### Discovering JavaScript
---
JavaScript is a scripting language that allows a developer to do all the fancy complex things you see when you visit web pages. JavaScript is used alongside HTML and CSS on the World Wide Web.

HTML is the markup language used to structure and give meaning to our web content: defining headings, and paragraphs, or embedding media like pictures or video content.

CSS is the language of style rules that we use to apply styling to HTML content. It can control background colors, fonts, and create multiple columns.

JavaScript is more complex than the previous code you viewed because you have to configure the HTTP and JavaScript components. In this code sample, “`window.alert`” will open a window and display “Hello World!”:


```javascript
<!DOCTYPE html>
<html>
<body>
<h2>Web Page</h2>
<p>Paragraph.</p>
<script>
window.alert("Hello World!");
</script>
</body>
</html>
```

JavaScript is very important to understand as a PenTester, as it is used heavily in XSS attacks and PenTesting.

## Topic 15B - Create Logic Constructs
---
> [!note] Exam Objectives Covered
> *5.1 Explain the basic concepts of scripting and software development.*

All computer programs and scripts require that you, as the programmer, define, for the computer, the components that you will be using within the program or script.

These components can include such constructs as: variables, logic, operators, flow control, conditionals, and loops, to name but a few.

These constructs are the building blocks of the programs and scripts you will be developing.

### Describing Variables
---
In programming, a **variable** is any value that is stored in memory and given a name or an identifier. In code, you assign values to these variables. As the name suggests, the values in a variable may change throughout the script's execution, but this is not required. The purpose of variables is to store values for later use, and to enable you to reference these values without explicitly writing them out in the code.

Many programming languages, like C, require you to define the type of variable before you assign it to a value. Examples of types include integers, floats, strings, and more. Essentially, these types define exactly what kind of information the variable holds.

However, you don't have to declare variable types in most scripts and interpreted languages used in this course (the exception is JavaScript where the variable must be declared). Instead, once you assign a value to a variable, that type is defined automatically.

> [!warning] The following examples describe the behavior of local variables. There are other types of variable scopes not covered here.

> [!warning] The following examples focus on Bash (Linux shell), PowerShell (Windows shell), and Python (code) examples. Whilst some examples of Ruby, Perl, and JavaScript are included, it would become very repetitive to include complete coverage of every option of every language. The purpose of this section is to teach the concepts, not the languages.

#### Bash Variable Assignment
Bash variables are assigned as follows:

`my_str="Hello, World!"`

<mark style="background: #FF5582A6;">Note the lack of whitespace around the equals sign—this is a strict rule in Bash. PowerShell, Python, and Ruby allow whitespace.</mark>

#### PowerShell Variables
You must use a dollar sign for variable assignment in PowerShell:

`$my_str = "Hello, World!"`

### Using Python and Ruby Variables
---
No dollar sign is necessary when assigning variables in Python or Ruby:

`my_str = "Hello, World!"`

#### Perl Variables
You must use a dollar sign for numeric/string variable assignment in Perl:

`$my_str = "Hello, World!";`

#### JavaScript Variables
JavaScript is the exception, the variable must be declared; however, you can declare it and assign a value on the same line:

`var my_str = "Hello, World!";`

### Applying Logic and Flow Control
---
A script's logic determines how it will process written code during execution. Even in languages like Python, where there is usually just one suggested way of doing something, there are various ways to design the logic of the code to essentially accomplish the same results in execution. Logic is therefore important in maximizing the efficiency and readability of code.

One of the most important components of a script's logic is flow control (or control flow), or the order in which code instructions are executed. Controlling the flow of instructions enables the programmers to write a script so that it can follow one or more paths based on certain circumstances.

One major example of flow control is the if statement. This is also known as a conditional or a logic statement. An if statement relies on certain conditions being true in order to proceed. Any code that is within this statement will execute only if the condition is met. Most languages also accommodate complex if statements that have multiple conditions. If condition one is not met, then condition two is evaluated, and so on.

Another major example of flow control is a loop. Instructions in a loop are carried out multiple times in succession. This makes it easier to perform the same or similar operations on multiple values or statements.

One type of loop is a while loop, which executes code while some condition is true and stops executing the code when the condition becomes false. Another type of loop is a for loop, which iterates through code a specific number of times, depending on what you specify. These types of loops are commonly used to process arrays and similar objects.

#### Bash Flow Control
The following is an if statement with a second condition (else). Note that the condition is in brackets and the code to be executed is under a then statement:
```bash
my_var=1
if [ $my_var == 1 ]
then echo
"Correct."
else
echo "Incorrect."
fi
```

The following is a while loop that increments `my_var` by one until it reaches ten:
```bash
my_var=1
while [ $my_var -lt 10 ]
do my_var=$((my_var + 1))
done
```

The following is a for loop that iterates through each value in an array. Note that the i iterator is just using an arbitrary name and can essentially be anything you want:
```bash
my_var=(1 2 3)
for i in ${my_var[*]}
do
echo $i
done
```

#### PowerShell Flow Control
The following is an if statement in PowerShell:
```powershell
$my_var = 1
if ($my_var -eq 1) {
Write-Host "Correct."
}
else {
Write-Host "Incorrect."
}
```

The following is a do-while loop in PowerShell, where the code block is executed at least once before the loop condition is evaluated:
```powershell
$my_var = 1
do
{ $my_var+=1 }
while ($my_var -lt 10)
```

The following is a for loop in PowerShell:
```powershell
$my_arr = 1,2,3
foreach ($i in $my_arr)
{ Write-Host $i
}
```

#### Python Flow Control
The following is an if statement in Python:  
```python
my_var = 1  
if my_var == 1:  
    print("Correct.")  
else:  
    print("Incorrect.")  
```
   
The following is a while loop in Python:  
```python
my_var = 1  
while my_var < 10:  
    my_var += 1  
```
   
The following is a for loop in Python:  
 ```python
 my_var = [1, 2, 3]  
for i in my_var:  
    print(i)
```

### Comparing Types of Operators
---
There are various types of operators you can use while scripting. Three of the most common operations are Boolean, Arithmetic, and String.

#### Boolean Operator
You previously saw an if statement in Python:
```python
my_var = 1
if my_var == 1:
print "Correct"
```

This is a simple command, 'if” the statement is true, it prints “Correct,” if the statement is not true, it skips the print “Correct” command and moves on.

Let’s review some **pseudocode**_._ Pseudocode is a made-up language used to show flow and logic but is not based on any programming or scripting language.

Let’s imagine we have a variable that holds the weather (`weatherType`) which could be sunny, raining, or snowing. We also have a variable that holds more detail about the conditions (`weatherConditions`), which could be windy, mild, or cold.

If we wanted to write a script that informed us if it was raining to take an umbrella with us, we could simply use:
```python
if weatherType = “raining”
print "Take an umbrella"
```

But what if we wanted to take an umbrella if it was raining but also if it was snowing. We could simply use:
```python
if weatherType = “raining”
print "Take an umbrella"
if weatherType = “snowing”
print "Take an umbrella"
```

However, we could combine these together using a logical OR. Logical OR is true, if either of the conditions is true:
```python
if weatherType = “raining” OR weatherType = “snowing”
print "Take an umbrella"
```

Now, consider that if we are concerned that if it is windy, our umbrella could be damaged, we could use an AND operator, which only evaluates as true if both conditions are true:
```python
if weatherType = “raining” AND weatherConditions = “windy”
print "Take a coat, it is too windy for an umbrella"
```

Finally, we may want to test for a series of events, such as whether it is raining or snowing. It may be easier to negate the third option rather than check for either of these two options. We could use a NOT operator, which only evaluates if the statement is true, but then inverts the true statement to false:
```python
if weatherType NOT= “sunny”
print "No need of sunglasses today!"
```

This may also be represented as:
```python
if NOT(weatherType = “sunny”)
print "No need of sunglasses today!"
```

In this example, if weatherType is anything but sunny, the message is printed.

When you combine the Boolean operators with scripting or coding, you can create complex conditionals, using easy to read code. For example, in Python:
```python
if ".xlsx" not in file:
file = file + ".xlsx"
```

Here, you are simply checking to see if the filename variable “file” contains an extension “.xlsx”. The variable file is already set up as a data structure holding a filename. If the filename does not end in “.xlsx,” we simply add that string into the variable before continuing with processing.

#### Arithmetic Operator
You could also perform basic arithmetic using code.

Let’s create some variables to demonstrate:
```python
value1 = 10
value2 = 2
```

Staying with pseudocode, you could perform basic addition:
```python
value3 = value1 + value2
print value3
```

would print the number 12.

The code snippet:
```python
value3 = value1 - value2
print value3
```

would print the value 8.

The code snippet:
```python
value3 = value1 * value2
print value3
```

would print the value 20.

Finally, the code snippet:
```python
value3 = value1 / value2
print value3
```

would print the value 5.

#### String Operator
You could also perform basic string manipulation using scripts and code.

Let’s create some variables to demonstrate:
```python
value1 = “hello”
value2 = “world”
value3 = “ “
```

The final value is a space character.

Staying with pseudocode, you could concatenate the strings:
```python
value4 = value1 + value3 + value2
print value4
```

would print “`hello world`”.

You could repeat the strings:
```python
value4 = value1 * 3
print value4
```

would print “`hellohellohello`”.

You could reference individual characters in a string as if it were an array:
```python
value4 = value1 + value3 + value2
print value4[0]
```

will print “`h`” (remember computers start counting from 0).

The code snippet:
```python
value4 = value1 + value3 + value2
print value4[1:4]
```

would print “`ello`” (characters 1 to 4, remember computers start counting from 0).

### Encoding Using JSON
---
JSON is an open standard data encoding format of data representation that can be used and manipulated easily with scripts. It is designed to be human-readable and machine processable. It is based on JavaScript concepts but is entirely script and language independent.

The most fundamental JSON syntax is based on a key-value pair. This is made of a key name and a value of that key separated by a colon(:):
`{“name”:”phil”}`

Keys must be text in double quotes. Strings must be included in double quotes. Data must be separated by commas. If the data is an object, it must be bounded by curly brackets. In fact, all JSON data has at least one curly bracket set. If an array is used, square brackets must be used.

In the example above, you see a string. Numbers can also be used:
`{“age”:25}`

Things can get complex as an object can contain other object types:
`{“man”:{“name”:”phil”, “age”:25}}`

Arrays can also be used:
`{“friends”:[“Henry”, ”Annmarie”, “Amy”]}`

In the example above, you have three friends.

JSON maps very well into Python Dictionaries for easy manipulation within Python.

### Python Data Structure Types
---
Python has multiple fundamental data types:

| **Data Type** | **Example**         |
| :-----------: | ------------------- |
|    Integer    | **`number = 1`**    |
|     Float     | **`number = 1.5`**  |
|    String     | **`name = "phil"`** |
|    Boolean    | **`event = True`**  |
Python also has advanced data types:

| List | **`friends = ["Henry", "Annmarie", "Amy"]`** |
| :--: | -------------------------------------------- |
Data, enclosed in `[]` and separated by commas. A list is simply what its name suggests: it is a list of things. Here, for example, is a list of friends: Henry, Annmarie, and Amy.

| Dictionary | **`friendsLocation = {"Henry":"TX", "Annmarie":"NY", "Amy":"FL"}`*** |
| :--------: | -------------------------------------------------------------------- |
A dictionary in Python is an object made up of key-value pairs enclosed in curly-brackets and separated by commas.

For example, the `friendsLocation` dictionary contains information about friends and where they live: Henry lives in Texas, Annmarie lives in New York, and Amy lives in Florida.

### Recognizing Other Data Constructs 
---
#### Comma-Separated Values
A comma-separated value (CSV) file is exactly as its name suggests: a file where entries are separated by commas. Originally used as an export from spreadsheets, CSV files have become a very popular way to import and export data. Complex data files can be transported as a CSV file in plain text.

Each entry in the CSV file is a field, and the fields are separated by commas. Typically, each line is an individual record. Considering a CSV as a spreadsheet, each field would be an entry in a column, and each line would be a row. Typically, the first line of a CSV file defines the field or column headers.

#### Trees
Trees are easily identified, as they appear inverted. In real-life, a tree sprouts from the roots in the ground up into the branches with leaves at the end. In data representation, the root is at the top, and the “branches” go down, with a “leaf” object at the end of a branch.

A great example of a tree structure is a company hierarchical reporting chart. The CEO is at the top, the executives are under the CEO, under each executive are three to five managers, and each manager could manage a group of potentially eight people.

In this example, the CEO would be the root of the tree structure. Each layer forms a parent-child layer with the nodes beneath it. So the CEO would be the parent of the executives as it were. If a node has no children, it is said to be a leaf, or an endpoint. The tree depth is the number of hops from leaf to root.

### Defining Object Oriented Programming
---
#### Functions
Functions, or Procedures, are used to produce modular, reusable code.

They allow us to group a block of code under a name and call this named function whenever we like. They usually take some arguments as parameters, perform some processing, and typically return some output.

When creating a script, you will use some functions from Python's modules and define your own functions. A function is defined using the following syntax:

```python
def fullname(name,surname):
return name + " " + surname
#This ends the function definition
#The next line calls the function to set a variable
greeting = 'Hello ' + fullname('World', '')
print(greeting)
```

> [!warning] Wherever possible, you should try to use procedures or functions as they tend to make your code more readable.

#### Classes
Once you grasp the concept of a re-useable function or procedure, the next step is to grasp a class.

A class is a user-defined prototype or template from which objects can be created. Classes allow you to bundle data and functionality together. A class creates user-defined data structures, which can hold their own functions.

#### Modules and Libraries
When you leave your environment, all the functions, variables, and classes you created are lost. Modules are a way to code re-useable functions, variables, and classes that can be imported into your scripts.

Writing your own modules allows you to use common constructs over and over again, defining them once. A module contains Python definitions and statements. The file name is simply the module name with the standard `.py` suffix.

Python has built-in libraries that are already coded for common functions that you may need. There are also repositories (libraries) of modules created by other people that can easily be referenced in your scripts (e.g., GitHub). Most of these repositories allow re-use, with terms defined in the repository.

All you have to do in Python to use a library module is to “import” it (if it is an external library module, you will, of course, need to download and install it, before it can be imported). Using the command “import” you declare the module you want to use.

Importing and using existing modules in libraries can save a lot of time, because you are re-using modules that have already been created, rather than having to create them from scratch.

## Topic 15C - Automate Penetration Testing
---
> [!note] Exam Objectives Covered
> *5.2 Given a scenario, analyze script or code sample for use in a penetration test.*

Penetration testing is a long, complex, and time-consuming process. Many of the tasks involved in this process are manual and repetitive and can easily lead to errors.

Automation of PenTesting, using scripts to do the repetitive tasks for you, not only saves time, but it can also reduce the probability of errors, thus leading to increased efficiency.

### Scanning Port Using Automation
---
In this section, we will use Python to create a very simple approach to automating penetration testing to provide an idea of what can be done.

First, imagine the following scenario: A client has provided us with a spreadsheet in .xslx format with a list of IP addresses that will be our targets for an upcoming penetration test.

The scan will be performed on an internal network and the main objective for our client is to identify common vulnerabilities and misconfigurations on secure channels such as SSL/TLS, which you’re told is being used extensively between local devices.

To achieve this, we will create a script that will automate these steps and produce a simple report. Let’s also assume that shortly prior to starting the assessment, the list of IP addresses has changed but no new list is provided – we’re told we can update it programmatically – so we’ll add a few lines to our script to update the IPs to be scanned.

The script will read a spreadsheet with a column titled “IP” that corresponds to our targets to be scanned.

![[Pasted image 20240618140500.png]]
*Sample spreadsheet of IP addresses for penetration testing.*

For each of those targets, we will first run a simple and fast scan looking only for open ports and for each IP address the results will be saved in a file in **greppable** format in order to perform searches using **regular expressions (regex)** .

Once the simple scan is done, the script will read the files and look for the open ports that were found and execute a second, slower, but more detailed analysis which will include identified vulnerabilities according to their version, as well as configuration issues in SSL/TLS communications, such as accepting weak ciphers.

The final results will be written to a text file as a human-readable report.

### Acquiring Scripts and Tools
---
We need to do a little setup to prepare the environment for Python. We need to install what is needed in our script. First, we need to use the Python installer pip3 to get the module and install it so Python can access it:

`pip3 install openpyxl`

Next, we get a script for Nmap from GitHub:

`git clone https://github.com/scipag/vulscan /opt/vulnscan`

This installs the script in the `/opt/vulnscan` folder. `/opt` is where we normally install optional tools for Linux. Next, we need to setup a symbolic link, referencing the actual folder the script is in:

`ln -s /opt/vulnscan /usr/share/nmap/scripts/vulscan`

This adds a symbolic link to allow Nmap to access the `/opt/vulnscan` folder, by referencing the `scripts/vulscan` folder link in its hierarchy.

### Reviewing The Script
---
```python
import os
import re
import openpyxl
import ipaddress

def fileread(file):
	if ".xlsx" not in file:
		file = file + ".xlsx"
	book = openpyxl.load_workbook(file)
	sheet = book.active		
	print("reading...")
	iplist = []
	for row in sheet.iter_rows(min_row=2, min_col=1, max_col=1):
		for cell in row:
			iplist.append(cell.value)
		return iplist

def ipupdate(iplist):
	newlist = []
	for ip in range(len(iplist)):
		newip = ipaddress.IPv4Address(iplist[ip])
		newlist.append(str(newip + 100))
	return newlist

def simplescan(iplist):
	for ip in range(len(iplist)):
		os.system("nmap -n -T4 -oG " + iplist[ip]
			+ "_simplescan.txt " + iplist[ip])
	print("Simple scan ready.")

def advancedscan(iplist):
	for ip in range(len(iplist)):
		file = open(iplist[ip] + "_simplescan.txt", "r").read()
		openports = re.findall(r"([0-9]*)\/open", file)
		ports = ",".join(openports)
		os.system("nmap -p " + ports + " -oN " + iplist[ip] + "_advscan.txt"
			+ " -sV --script=vulnscan,ssl-enum-ciphers " + iplist[ip])
	print("Advanced scan ready.")

if __name__ == "__main__":
	iplist = []
	try:
		file = input("Enter the name of spreadsheet to read:\n")
		iplist = fileread(file)
	except:
		print("Error reading specified file")
		exit(1)
	iplist = ipupdate(iplist)
	simplescan(iplist)
	advancedscan(iplist)
	print("All operations finished.")
```

### Breaking Down The Script
---
Let’s look into the different sections of the code and examine what they are doing.

The first step is to import the Python modules that we will need. We will use the **openpyxl** module to read the list of targets from the xlsx file, the module **ipaddress** to modify the addresses of the targets, **os** to execute nmap scans and save the results, and finally the **re** module to use **regular expressions** and look for information within the text files.

Regular expressions are useful, for example, when looking for open ports within results regardless of the port number itself, as there might be different open ports between different targets.

#### Import Needed Python Modules
```python
import os
import re
import openpyxl
import ipaddress
```

The first function will read from the spreadsheet and iterate over the first column of IP addresses to create a list. The code will look for the existence of the .xlsx extension in the file, and if it is not present, it will add it. You could later modify the code to include other formats.

We then open the file using `openpyxl` and start reading from the first sheet to create the list of targets, looking at only the first column where the addresses are, but starting at the second row since the first row contains the title “`IP`”.

#### Definition of "`fileread`" Function
```python
def fileread(file):
	if ".xlsx" not in file:
		file = file + ".xlsx"
	book = openpyxl.load_workbook(file)
	sheet = book.active
	print("reading...")
	iplist = []
	for row in sheet.iter_rows(min_row=2, min_col=1, max_col=1):
		for cell in row:
			iplist.append(cell.value)
	return iplist
```

To update the list of IPs we’ll use the module `ipaddress`. It has several uses to analyze and manipulate both addresses and networks but, for now, we need to perform a very simple change: our targets were given new IP addresses within the same subnet but shifted by 100 (`192.168.0.3` is now `192.168.0.103`).

It would be tedious to manually change each but, luckily for us, the `ipaddress` module allows us to do basic arithmetic operations. We will use the Python ipaddress module from our defined `ipupdate` function:

#### Definition of "`ipupdate`" Function
```python
def ipupdate(iplist):
	newlist = []
	for ip in range(len(iplist)):
		newip = ipaddress.IPv4Address(iplist[ip])
		newlist.append(str(newip + 100))
	return newlist
```

We could also use this part of the script to perform several other checks, such as whether the IP addresses are valid, or not, before running the scans.

Similarly, since we are scanning a local network, we could check that the addresses are not external ones and remove them from the list. There are more uses that we could configure but, for now, let’s continue with the **simplescan** function that follows:

#### Definition of "`simplescan`" Function
```python
def simplescan(iplist):
	for ip in range(len(iplist)):
		os.system("nmap -n -T4 -oG " + iplist[ip]
			+"_simplescan.txt " + iplist[ip])
	print("Simple scan ready.")
```

This function will receive our list of IPs, loop through it, and for each IP perform a fast, simple scan of the target looking for open ports. To achieve this we can use **`os.system()`** to execute commands as if we were in the terminal ourselves.

Here, we can run Nmap with certain options to make a fast scan. The first option, **`-T4`**, deals with timing templates that range from 0 to 5 (default is 3). In this instance, we are specifying the use of a particular one: 4 or “aggressive”, which will reduce the delays, retries, and timeouts for the tests to run. The option **-n** skips the DNS resolution, which will make our scan considerably faster.

According to Nmap's website ([https://nmap.org/book/reduce-scantime.html](https://nmap.org/book/reduce-scantime.html)): "By default, Nmap performs reverse-DNS resolution against every host that is found to be online. […] Disable them with the -n option when you don't need the data. For simple scans (such as ping scans) against a large number of hosts, omitting DNS can sometimes reduce scan time by 20% or more."

The command also saves a greppable output with the option **`-oG`** and the name of the file. Here, we are concatenating strings to scan each IP address in the spreadsheet and save a file with the IP address as name, followed by the string “`_simplescan.txt`” (for example: “ `_192.168.0.101_simplescan.txt`”) .

Now it is time for the advanced scan. This one will take longer because it will attempt to obtain further details from these targets, such as the software and version of each of the open ports that we found during the simple scan:

#### Definition of "`advancedscan`" Function
```python
def advancedscan(iplist):
	for ip in range(len(iplist)):
		file = open(iplist[ip] + "_simplescan.txt", "r").read()
		openports = re.findall(r"([0-9]*)\/open", file)
		ports = ",".join(openports)
		os.system("nmap -p " + ports + " -oN " + iplist[ip] + "_advscan.txt"
			+ " -sV --script=vulnscan,ssl-enum-ciphers " + iplist[ip])
	print("Advanced scan ready.")
```

Similar to the code section from the simple scan, we loop through the list of IP addresses to create our list of targets only, this time, we will look into the text file with the list of open ports and perform an advanced scan with two Nmap options.

The first Nmap option, **`-sV`**, performs version detection on the open ports that are found. In its simple form, this process is generally known as banner grabbing, but Nmap takes it a step further with this option, making use of its own database of services and probes to test them, and then prints only the identified software and version that is listening on that port.

For example, instead of the whole HTTP reply from an Apache Web server you would get from banner grabbing, Nmap will simply display:

`80/tcp open http Apache httpd 2.2.8 ((Ubuntu) DAV/2)`

The second Nmap option **`--script`** allows us to run Nmap scripts and, in particular for our case, they will run dedicated analysis on the services we find.

Nmap has a library of scripts for many different use cases, which are usually located in Linux in _`/usr/share/nmap/scripts/vulscan`_ ( or, in Windows, `C:\Program Files (x86)\nmap\scripts\` ).

For our objective of identifying vulnerabilities and weak ciphers our targets accept, we can use scripts already included in Nmap’s library: **`vulners`** & **`ssl-enum-ciphers`**. In particular, `vulners` has a vast database of known vulnerabilities but because we’re trying to limit the load in our client’s network, and `vulners` queries online sources for each service it identifies, we can use a smaller, local alternative: **vulnscan** ( [https://github.com/scipag/vulscan](https://github.com/scipag/vulscan) ).

To identify the ciphers that the secure services are using, `ssl-enum-ciphers` will initiate several connections using different settings and will give a score according to the support of different protocols (SSLv3, TLSv1.1, etc.), the key exchange, and cipher strength. This score is based on Qualy’s SSL Server Ratings ([https://github.com/ssllabs/research/wiki/SSL-Server-Rating-Guide](https://github.com/ssllabs/research/wiki/SSL-Server-Rating-Guide)).

Here we are, again, concatenating strings to scan each IP address and create a report file with the IP address as name, followed by the string “`_advscan.txt`” (for example: “`_192.168.0.101_advscan.txt`”).

Finally, we have the main function that will control our script’s flow. As such, we add a try/catch statement in case there’s an error reading the file, then continue with calls for each of the functions we created:

#### Create "`main`" Function
```python
if __name__ == "__main__":
	iplist = []
	try:
		file = input("Enter the name of spreadsheet to read:\n")
		iplist = fileread(file)
	except:
		print("Error reading specified file")
		exit(1)
	iplist = ipupdate(iplist)
	simplescan(iplist)
	advancedscan(iplist)
	print("All operations finished.")
```

That brings you to the end of this script that is an example of how you can automate your PenTesting with scripts and code.
